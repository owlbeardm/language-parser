-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Keyed functors and containers
--   
--   This package provides a bunch of ad hoc classes for accessing parts of
--   a container.
--   
--   In practice this package is largely subsumed by the <a>lens
--   package</a>, but it is maintained for now as it has much simpler
--   dependencies.
@package keys
@version 3.12.2

module Data.Key
type family Key (f :: * -> *)
class Functor f => Keyed f
mapWithKey :: Keyed f => (Key f -> a -> b) -> f a -> f b
(<#$>) :: Keyed f => (Key f -> a -> b) -> f a -> f b
infixl 4 <#$>
keyed :: Keyed f => f a -> f (Key f, a)

-- | Laws:
--   
--   <pre>
--   <a>fmap</a> <a>fst</a> (<a>zip</a> u u) = u
--   <a>fmap</a> <a>snd</a> (<a>zip</a> u u) = u
--   <a>zip</a> (<a>fmap</a> <a>fst</a> u) (<a>fmap</a> <a>snd</a> u) = u
--   <a>zip</a> (<a>flip</a> (,)) x y = <a>zip</a> y x
--   </pre>
class Functor f => Zip f
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c
zip :: Zip f => f a -> f b -> f (a, b)
zap :: Zip f => f (a -> b) -> f a -> f b
class (Keyed f, Zip f) => ZipWithKey f
zipWithKey :: ZipWithKey f => (Key f -> a -> b -> c) -> f a -> f b -> f c
zapWithKey :: ZipWithKey f => f (Key f -> a -> b) -> f a -> f b
class Lookup f => Indexable f
index :: Indexable f => f a -> Key f -> a
(!) :: Indexable f => f a -> Key f -> a
class Lookup f
lookup :: Lookup f => Key f -> f a -> Maybe a
lookupDefault :: Indexable f => Key f -> f a -> Maybe a
class Functor f => Adjustable f
adjust :: Adjustable f => (a -> a) -> Key f -> f a -> f a
replace :: Adjustable f => Key f -> a -> f a -> f a
class Foldable t => FoldableWithKey t
toKeyedList :: FoldableWithKey t => t a -> [(Key t, a)]
foldMapWithKey :: (FoldableWithKey t, Monoid m) => (Key t -> a -> m) -> t a -> m
foldrWithKey :: FoldableWithKey t => (Key t -> a -> b -> b) -> b -> t a -> b
foldlWithKey :: FoldableWithKey t => (b -> Key t -> a -> b) -> b -> t a -> b
foldrWithKey' :: FoldableWithKey t => (Key t -> a -> b -> b) -> b -> t a -> b
foldlWithKey' :: FoldableWithKey t => (b -> Key t -> a -> b) -> b -> t a -> b
foldrWithKeyM :: (FoldableWithKey t, Monad m) => (Key t -> a -> b -> m b) -> b -> t a -> m b
foldlWithKeyM :: (FoldableWithKey t, Monad m) => (b -> Key t -> a -> m b) -> b -> t a -> m b
traverseWithKey_ :: (FoldableWithKey t, Applicative f) => (Key t -> a -> f b) -> t a -> f ()
forWithKey_ :: (FoldableWithKey t, Applicative f) => t a -> (Key t -> a -> f b) -> f ()
mapWithKeyM_ :: (FoldableWithKey t, Monad m) => (Key t -> a -> m b) -> t a -> m ()
forWithKeyM_ :: (FoldableWithKey t, Monad m) => t a -> (Key t -> a -> m b) -> m ()
concatMapWithKey :: FoldableWithKey t => (Key t -> a -> [b]) -> t a -> [b]
anyWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Bool
allWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Bool
findWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Maybe a
class (Foldable1 t, FoldableWithKey t) => FoldableWithKey1 t
foldMapWithKey1 :: (FoldableWithKey1 t, Semigroup m) => (Key t -> a -> m) -> t a -> m
traverseWithKey1_ :: (FoldableWithKey1 t, Apply f) => (Key t -> a -> f b) -> t a -> f ()
forWithKey1_ :: (FoldableWithKey1 t, Apply f) => t a -> (Key t -> a -> f b) -> f ()
foldMapWithKeyDefault1 :: (FoldableWithKey1 t, Monoid m) => (Key t -> a -> m) -> t a -> m
class (Keyed t, FoldableWithKey t, Traversable t) => TraversableWithKey t
traverseWithKey :: (TraversableWithKey t, Applicative f) => (Key t -> a -> f b) -> t a -> f (t b)
mapWithKeyM :: (TraversableWithKey t, Monad m) => (Key t -> a -> m b) -> t a -> m (t b)
forWithKey :: (TraversableWithKey t, Applicative f) => t a -> (Key t -> a -> f b) -> f (t b)
forWithKeyM :: (TraversableWithKey t, Monad m) => t a -> (Key t -> a -> m b) -> m (t b)

-- | The <a>mapAccumWithKeyL</a> function behaves like a combination of
--   <a>mapWithKey</a> and <a>foldlWithKey</a>; it applies a function to
--   each element of a structure, passing an accumulating parameter from
--   left to right, and returning a final value of this accumulator
--   together with the new structure.
mapAccumWithKeyL :: TraversableWithKey t => (Key t -> a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumWithKeyR</a> function behaves like a combination of
--   <a>mapWithKey</a> and <a>foldrWithKey</a>; it applies a function to
--   each element of a structure, passing an accumulating parameter from
--   right to left, and returning a final value of this accumulator
--   together with the new structure.
mapAccumWithKeyR :: TraversableWithKey t => (Key t -> a -> b -> (a, c)) -> a -> t b -> (a, t c)
mapWithKeyDefault :: TraversableWithKey t => (Key t -> a -> b) -> t a -> t b

-- | This function may be used as a value for <a>foldMapWithKey</a> in a
--   <a>FoldableWithKey</a> instance.
foldMapWithKeyDefault :: (TraversableWithKey t, Monoid m) => (Key t -> a -> m) -> t a -> m
class (Traversable1 t, FoldableWithKey1 t, TraversableWithKey t) => TraversableWithKey1 t
traverseWithKey1 :: (TraversableWithKey1 t, Apply f) => (Key t -> a -> f b) -> t a -> f (t b)
foldMapWithKey1Default :: (TraversableWithKey1 t, Semigroup m) => (Key t -> a -> m) -> t a -> m
instance Data.Key.TraversableWithKey1 (Data.Tagged.Tagged a)
instance Data.Key.TraversableWithKey1 f => Data.Key.TraversableWithKey1 (Control.Comonad.Cofree.Cofree f)
instance Data.Key.TraversableWithKey1 Data.Tree.Tree
instance Data.Key.TraversableWithKey1 f => Data.Key.TraversableWithKey1 (Control.Monad.Free.Free f)
instance Data.Key.TraversableWithKey1 GHC.Generics.Par1
instance Data.Key.TraversableWithKey1 f => Data.Key.TraversableWithKey1 (GHC.Generics.Rec1 f)
instance Data.Key.TraversableWithKey1 f => Data.Key.TraversableWithKey1 (GHC.Generics.M1 i c f)
instance Data.Key.TraversableWithKey1 GHC.Generics.V1
instance (Data.Key.TraversableWithKey1 f, Data.Key.TraversableWithKey1 g) => Data.Key.TraversableWithKey1 (f GHC.Generics.:*: g)
instance (Data.Key.TraversableWithKey1 f, Data.Key.TraversableWithKey1 g) => Data.Key.TraversableWithKey1 (f GHC.Generics.:+: g)
instance Data.Key.TraversableWithKey1 Data.Functor.Identity.Identity
instance Data.Key.TraversableWithKey1 m => Data.Key.TraversableWithKey1 (Control.Monad.Trans.Identity.IdentityT m)
instance (Data.Key.TraversableWithKey1 f, Data.Key.TraversableWithKey1 m) => Data.Key.TraversableWithKey1 (Data.Functor.Compose.Compose f m)
instance Data.Key.TraversableWithKey1 GHC.Base.NonEmpty
instance (Data.Key.TraversableWithKey1 f, Data.Key.TraversableWithKey1 g) => Data.Key.TraversableWithKey1 (Data.Functor.Sum.Sum f g)
instance (Data.Key.TraversableWithKey1 f, Data.Key.TraversableWithKey1 g) => Data.Key.TraversableWithKey1 (Data.Functor.Product.Product f g)
instance Data.Key.TraversableWithKey1 ((,) k)
instance GHC.Base.Functor (Data.Key.StateR s)
instance GHC.Base.Applicative (Data.Key.StateR s)
instance GHC.Base.Functor (Data.Key.StateL s)
instance GHC.Base.Applicative (Data.Key.StateL s)
instance Data.Key.TraversableWithKey (Data.Tagged.Tagged a)
instance Data.Key.TraversableWithKey Data.Proxy.Proxy
instance Data.Key.TraversableWithKey f => Data.Key.TraversableWithKey (Control.Comonad.Cofree.Cofree f)
instance Data.Key.TraversableWithKey Data.Tree.Tree
instance Data.Key.TraversableWithKey f => Data.Key.TraversableWithKey (Control.Monad.Free.Free f)
instance (Data.Key.TraversableWithKey f, Data.Key.TraversableWithKey g) => Data.Key.TraversableWithKey (f GHC.Generics.:*: g)
instance (Data.Key.TraversableWithKey f, Data.Key.TraversableWithKey g) => Data.Key.TraversableWithKey (f GHC.Generics.:+: g)
instance Data.Key.TraversableWithKey GHC.Generics.Par1
instance Data.Key.TraversableWithKey GHC.Generics.U1
instance Data.Key.TraversableWithKey GHC.Generics.V1
instance Data.Key.TraversableWithKey (GHC.Generics.K1 i c)
instance Data.Key.TraversableWithKey f => Data.Key.TraversableWithKey (GHC.Generics.Rec1 f)
instance Data.Key.TraversableWithKey f => Data.Key.TraversableWithKey (GHC.Generics.M1 i c f)
instance Data.Key.TraversableWithKey Data.Functor.Identity.Identity
instance Data.Key.TraversableWithKey m => Data.Key.TraversableWithKey (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.TraversableWithKey Data.IntMap.Internal.IntMap
instance (Data.Key.TraversableWithKey f, Data.Key.TraversableWithKey m) => Data.Key.TraversableWithKey (Data.Functor.Compose.Compose f m)
instance Data.Key.TraversableWithKey []
instance Data.Key.TraversableWithKey Control.Applicative.ZipList
instance Data.Key.TraversableWithKey GHC.Base.NonEmpty
instance Data.Key.TraversableWithKey Data.Sequence.Internal.Seq
instance Data.Key.TraversableWithKey (Data.Map.Internal.Map k)
instance GHC.Arr.Ix i => Data.Key.TraversableWithKey (GHC.Arr.Array i)
instance (Data.Key.TraversableWithKey f, Data.Key.TraversableWithKey g) => Data.Key.TraversableWithKey (Data.Functor.Sum.Sum f g)
instance (Data.Key.TraversableWithKey f, Data.Key.TraversableWithKey g) => Data.Key.TraversableWithKey (Data.Functor.Product.Product f g)
instance Data.Key.TraversableWithKey ((,) k)
instance Data.Key.TraversableWithKey (Data.HashMap.Base.HashMap k)
instance Data.Key.TraversableWithKey GHC.Maybe.Maybe
instance Data.Functor.Bind.Class.Apply f => GHC.Base.Semigroup (Data.Key.Act f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Key.Act f)
instance Data.Key.FoldableWithKey1 f => Data.Key.FoldableWithKey1 (Control.Comonad.Cofree.Cofree f)
instance Data.Key.FoldableWithKey1 Data.Tree.Tree
instance Data.Key.FoldableWithKey1 f => Data.Key.FoldableWithKey1 (Control.Monad.Free.Free f)
instance Data.Key.FoldableWithKey1 (Data.Tagged.Tagged a)
instance (Data.Key.FoldableWithKey1 f, Data.Key.FoldableWithKey1 g) => Data.Key.FoldableWithKey1 (f GHC.Generics.:*: g)
instance (Data.Key.FoldableWithKey1 f, Data.Key.FoldableWithKey1 g) => Data.Key.FoldableWithKey1 (f GHC.Generics.:+: g)
instance Data.Key.FoldableWithKey1 GHC.Generics.V1
instance Data.Key.FoldableWithKey1 GHC.Generics.Par1
instance Data.Key.FoldableWithKey1 f => Data.Key.FoldableWithKey1 (GHC.Generics.M1 i c f)
instance Data.Key.FoldableWithKey1 f => Data.Key.FoldableWithKey1 (GHC.Generics.Rec1 f)
instance Data.Key.FoldableWithKey1 Data.Functor.Identity.Identity
instance Data.Key.FoldableWithKey1 m => Data.Key.FoldableWithKey1 (Control.Monad.Trans.Identity.IdentityT m)
instance (Data.Key.FoldableWithKey1 f, Data.Key.FoldableWithKey1 m) => Data.Key.FoldableWithKey1 (Data.Functor.Compose.Compose f m)
instance Data.Key.FoldableWithKey1 GHC.Base.NonEmpty
instance (Data.Key.FoldableWithKey1 f, Data.Key.FoldableWithKey1 g) => Data.Key.FoldableWithKey1 (Data.Functor.Sum.Sum f g)
instance (Data.Key.FoldableWithKey1 f, Data.Key.FoldableWithKey1 g) => Data.Key.FoldableWithKey1 (Data.Functor.Product.Product f g)
instance Data.Key.FoldableWithKey1 ((,) k)
instance Data.Key.FoldableWithKey f => Data.Key.FoldableWithKey (Control.Monad.Free.Free f)
instance Data.Key.FoldableWithKey f => Data.Key.FoldableWithKey (Control.Comonad.Cofree.Cofree f)
instance Data.Key.FoldableWithKey (Data.Tagged.Tagged a)
instance Data.Key.FoldableWithKey Data.Proxy.Proxy
instance Data.Key.FoldableWithKey Data.Tree.Tree
instance Data.Key.FoldableWithKey GHC.Generics.Par1
instance (Data.Key.FoldableWithKey f, Data.Key.FoldableWithKey g) => Data.Key.FoldableWithKey (f GHC.Generics.:*: g)
instance (Data.Key.FoldableWithKey f, Data.Key.FoldableWithKey g) => Data.Key.FoldableWithKey (f GHC.Generics.:+: g)
instance Data.Key.FoldableWithKey GHC.Generics.U1
instance Data.Key.FoldableWithKey GHC.Generics.V1
instance Data.Key.FoldableWithKey (GHC.Generics.K1 i c)
instance Data.Key.FoldableWithKey f => Data.Key.FoldableWithKey (GHC.Generics.M1 i c f)
instance Data.Key.FoldableWithKey f => Data.Key.FoldableWithKey (GHC.Generics.Rec1 f)
instance Data.Key.FoldableWithKey Data.Functor.Identity.Identity
instance Data.Key.FoldableWithKey m => Data.Key.FoldableWithKey (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.FoldableWithKey Data.IntMap.Internal.IntMap
instance (Data.Key.FoldableWithKey f, Data.Key.FoldableWithKey m) => Data.Key.FoldableWithKey (Data.Functor.Compose.Compose f m)
instance Data.Key.FoldableWithKey []
instance Data.Key.FoldableWithKey Control.Applicative.ZipList
instance Data.Key.FoldableWithKey GHC.Base.NonEmpty
instance Data.Key.FoldableWithKey Data.Sequence.Internal.Seq
instance Data.Key.FoldableWithKey (Data.Map.Internal.Map k)
instance GHC.Arr.Ix i => Data.Key.FoldableWithKey (GHC.Arr.Array i)
instance (Data.Key.FoldableWithKey f, Data.Key.FoldableWithKey g) => Data.Key.FoldableWithKey (Data.Functor.Sum.Sum f g)
instance (Data.Key.FoldableWithKey f, Data.Key.FoldableWithKey g) => Data.Key.FoldableWithKey (Data.Functor.Product.Product f g)
instance Data.Key.FoldableWithKey ((,) k)
instance Data.Key.FoldableWithKey (Data.HashMap.Base.HashMap k)
instance Data.Key.FoldableWithKey GHC.Maybe.Maybe
instance Data.Key.Adjustable f => Data.Key.Adjustable (Control.Monad.Free.Free f)
instance Data.Key.Adjustable f => Data.Key.Adjustable (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Adjustable Data.Tree.Tree
instance Data.Key.Adjustable (Data.Tagged.Tagged a)
instance Data.Key.Adjustable Data.Proxy.Proxy
instance Data.Key.Adjustable GHC.Generics.U1
instance Data.Key.Adjustable GHC.Generics.Par1
instance Data.Key.Adjustable f => Data.Key.Adjustable (GHC.Generics.Rec1 f)
instance Data.Key.Adjustable f => Data.Key.Adjustable (GHC.Generics.M1 i c f)
instance Data.Key.Adjustable (GHC.Generics.K1 i c)
instance (Data.Key.Adjustable f, Data.Key.Adjustable g) => Data.Key.Adjustable (f GHC.Generics.:+: g)
instance (Data.Key.Adjustable f, Data.Key.Adjustable g) => Data.Key.Adjustable (f GHC.Generics.:*: g)
instance (Data.Key.Adjustable f, Data.Key.Adjustable g) => Data.Key.Adjustable (g GHC.Generics.:.: f)
instance Data.Key.Adjustable Data.Functor.Identity.Identity
instance Data.Key.Adjustable Data.IntMap.Internal.IntMap
instance Data.Key.Adjustable []
instance Data.Key.Adjustable Control.Applicative.ZipList
instance Data.Key.Adjustable GHC.Base.NonEmpty
instance Data.Key.Adjustable Data.Sequence.Internal.Seq
instance GHC.Classes.Ord k => Data.Key.Adjustable (Data.Map.Internal.Map k)
instance GHC.Arr.Ix i => Data.Key.Adjustable (GHC.Arr.Array i)
instance (Data.Key.Adjustable f, Data.Key.Adjustable g) => Data.Key.Adjustable (Data.Functor.Sum.Sum f g)
instance (Data.Key.Adjustable f, Data.Key.Adjustable g) => Data.Key.Adjustable (Data.Functor.Product.Product f g)
instance Data.Key.Indexable f => Data.Key.Indexable (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Indexable (Data.Tagged.Tagged a)
instance Data.Key.Indexable Data.Proxy.Proxy
instance Data.Key.Indexable Data.Tree.Tree
instance Data.Key.Indexable GHC.Generics.U1
instance Data.Key.Indexable GHC.Generics.Par1
instance Data.Key.Indexable f => Data.Key.Indexable (GHC.Generics.Rec1 f)
instance Data.Key.Indexable f => Data.Key.Indexable (GHC.Generics.M1 i c f)
instance Data.Key.Indexable (GHC.Generics.K1 i c)
instance (Data.Key.Indexable g, Data.Key.Indexable f) => Data.Key.Indexable (f GHC.Generics.:*: g)
instance (Data.Key.Indexable g, Data.Key.Indexable f) => Data.Key.Indexable (g GHC.Generics.:.: f)
instance (Data.Key.Indexable g, Data.Key.Indexable f) => Data.Key.Lookup (f GHC.Generics.:*: g)
instance (Data.Key.Indexable g, Data.Key.Indexable f) => Data.Key.Lookup (g GHC.Generics.:.: f)
instance Data.Key.Indexable Data.Functor.Identity.Identity
instance Data.Key.Indexable m => Data.Key.Indexable (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.Indexable ((->) a)
instance Data.Key.Indexable m => Data.Key.Indexable (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.Indexable w => Data.Key.Indexable (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.Indexable Data.IntMap.Internal.IntMap
instance (Data.Key.Indexable f, Data.Key.Indexable g) => Data.Key.Indexable (Data.Functor.Compose.Compose f g)
instance Data.Key.Indexable []
instance Data.Key.Indexable Control.Applicative.ZipList
instance Data.Key.Indexable GHC.Base.NonEmpty
instance Data.Key.Indexable Data.Sequence.Internal.Seq
instance GHC.Classes.Ord k => Data.Key.Indexable (Data.Map.Internal.Map k)
instance GHC.Arr.Ix i => Data.Key.Indexable (GHC.Arr.Array i)
instance (Data.Key.Indexable f, Data.Key.Indexable g) => Data.Key.Indexable (Data.Functor.Sum.Sum f g)
instance (Data.Key.Indexable f, Data.Key.Indexable g) => Data.Key.Indexable (Data.Functor.Product.Product f g)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Key.Indexable (Data.HashMap.Base.HashMap k)
instance Data.Key.Indexable GHC.Maybe.Maybe
instance Data.Key.Lookup f => Data.Key.Lookup (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Lookup (Data.Tagged.Tagged a)
instance Data.Key.Lookup Data.Proxy.Proxy
instance Data.Key.Lookup Data.Tree.Tree
instance Data.Key.Lookup f => Data.Key.Lookup (Control.Monad.Free.Free f)
instance Data.Key.Lookup GHC.Generics.U1
instance Data.Key.Lookup GHC.Generics.Par1
instance Data.Key.Lookup f => Data.Key.Lookup (GHC.Generics.Rec1 f)
instance Data.Key.Lookup f => Data.Key.Lookup (GHC.Generics.M1 i c f)
instance Data.Key.Lookup (GHC.Generics.K1 i c)
instance Data.Key.Lookup Data.Functor.Identity.Identity
instance Data.Key.Lookup m => Data.Key.Lookup (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.Lookup ((->) a)
instance Data.Key.Lookup m => Data.Key.Lookup (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.Lookup w => Data.Key.Lookup (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.Lookup Data.IntMap.Internal.IntMap
instance (Data.Key.Lookup f, Data.Key.Lookup g) => Data.Key.Lookup (Data.Functor.Compose.Compose f g)
instance Data.Key.Lookup []
instance Data.Key.Lookup Control.Applicative.ZipList
instance Data.Key.Lookup GHC.Base.NonEmpty
instance Data.Key.Lookup Data.Sequence.Internal.Seq
instance GHC.Classes.Ord k => Data.Key.Lookup (Data.Map.Internal.Map k)
instance GHC.Arr.Ix i => Data.Key.Lookup (GHC.Arr.Array i)
instance (Data.Key.Lookup f, Data.Key.Lookup g) => Data.Key.Lookup (Data.Functor.Sum.Sum f g)
instance (Data.Key.Lookup f, Data.Key.Lookup g) => Data.Key.Lookup (Data.Functor.Product.Product f g)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Key.Lookup (Data.HashMap.Base.HashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Key.ZipWithKey (Data.HashMap.Base.HashMap k)
instance Data.Key.Lookup GHC.Maybe.Maybe
instance Data.Key.ZipWithKey f => Data.Key.ZipWithKey (Control.Comonad.Cofree.Cofree f)
instance Data.Key.ZipWithKey Data.Tree.Tree
instance Data.Key.ZipWithKey (Data.Tagged.Tagged a)
instance Data.Key.ZipWithKey Data.Proxy.Proxy
instance Data.Key.ZipWithKey GHC.Generics.U1
instance Data.Key.ZipWithKey GHC.Generics.V1
instance Data.Key.ZipWithKey GHC.Generics.Par1
instance Data.Key.ZipWithKey f => Data.Key.ZipWithKey (GHC.Generics.Rec1 f)
instance Data.Key.ZipWithKey f => Data.Key.ZipWithKey (GHC.Generics.M1 i c f)
instance (Data.Key.ZipWithKey f, Data.Key.ZipWithKey g) => Data.Key.ZipWithKey (f GHC.Generics.:*: g)
instance (Data.Key.ZipWithKey f, Data.Key.ZipWithKey g) => Data.Key.ZipWithKey (g GHC.Generics.:.: f)
instance Data.Key.ZipWithKey Data.Functor.Identity.Identity
instance Data.Key.ZipWithKey m => Data.Key.ZipWithKey (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.ZipWithKey ((->) a)
instance Data.Key.ZipWithKey m => Data.Key.ZipWithKey (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.ZipWithKey w => Data.Key.ZipWithKey (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.ZipWithKey Data.IntMap.Internal.IntMap
instance (Data.Key.ZipWithKey f, Data.Key.ZipWithKey g) => Data.Key.ZipWithKey (Data.Functor.Compose.Compose f g)
instance Data.Key.ZipWithKey []
instance Data.Key.ZipWithKey Control.Applicative.ZipList
instance Data.Key.ZipWithKey GHC.Base.NonEmpty
instance Data.Key.ZipWithKey Data.Sequence.Internal.Seq
instance GHC.Classes.Ord k => Data.Key.ZipWithKey (Data.Map.Internal.Map k)
instance (Data.Key.ZipWithKey f, Data.Key.ZipWithKey g) => Data.Key.ZipWithKey (Data.Functor.Product.Product f g)
instance Data.Key.ZipWithKey GHC.Maybe.Maybe
instance Data.Key.Zip f => Data.Key.Zip (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Zip Data.Tree.Tree
instance Data.Key.Zip Data.Proxy.Proxy
instance Data.Key.Zip (Data.Tagged.Tagged a)
instance Data.Key.Zip GHC.Generics.U1
instance Data.Key.Zip GHC.Generics.V1
instance Data.Key.Zip GHC.Generics.Par1
instance (Data.Key.Zip f, Data.Key.Zip g) => Data.Key.Zip (f GHC.Generics.:*: g)
instance (Data.Key.Zip f, Data.Key.Zip g) => Data.Key.Zip (g GHC.Generics.:.: f)
instance Data.Key.Zip f => Data.Key.Zip (GHC.Generics.Rec1 f)
instance Data.Key.Zip f => Data.Key.Zip (GHC.Generics.M1 i c f)
instance Data.Key.Zip Data.Functor.Identity.Identity
instance Data.Key.Zip m => Data.Key.Zip (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.Zip ((->) a)
instance Data.Key.Zip m => Data.Key.Zip (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.Zip w => Data.Key.Zip (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.Zip Data.IntMap.Internal.IntMap
instance (Data.Key.Zip f, Data.Key.Zip g) => Data.Key.Zip (Data.Functor.Compose.Compose f g)
instance Data.Key.Zip []
instance Data.Key.Zip Control.Applicative.ZipList
instance Data.Key.Zip GHC.Base.NonEmpty
instance Data.Key.Zip Data.Sequence.Internal.Seq
instance GHC.Classes.Ord k => Data.Key.Zip (Data.Map.Internal.Map k)
instance (Data.Key.Zip f, Data.Key.Zip g) => Data.Key.Zip (Data.Functor.Product.Product f g)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Key.Zip (Data.HashMap.Base.HashMap k)
instance Data.Key.Zip GHC.Maybe.Maybe
instance Data.Key.Keyed f => Data.Key.Keyed (Control.Monad.Free.Free f)
instance Data.Key.Keyed f => Data.Key.Keyed (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Keyed Data.Tree.Tree
instance Data.Key.Keyed GHC.Generics.U1
instance Data.Key.Keyed GHC.Generics.V1
instance Data.Key.Keyed GHC.Generics.Par1
instance Data.Key.Keyed (GHC.Generics.K1 i c)
instance Data.Key.Keyed (Data.Tagged.Tagged a)
instance Data.Key.Keyed Data.Proxy.Proxy
instance Data.Key.Keyed f => Data.Key.Keyed (GHC.Generics.M1 i c f)
instance Data.Key.Keyed f => Data.Key.Keyed (GHC.Generics.Rec1 f)
instance (Data.Key.Keyed g, Data.Key.Keyed f) => Data.Key.Keyed (f GHC.Generics.:*: g)
instance (Data.Key.Keyed g, Data.Key.Keyed f) => Data.Key.Keyed (f GHC.Generics.:+: g)
instance (Data.Key.Keyed g, Data.Key.Keyed f) => Data.Key.Keyed (g GHC.Generics.:.: f)
instance Data.Key.Keyed Data.Functor.Identity.Identity
instance Data.Key.Keyed m => Data.Key.Keyed (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.Keyed ((->) a)
instance Data.Key.Keyed m => Data.Key.Keyed (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.Keyed w => Data.Key.Keyed (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.Keyed Data.IntMap.Internal.IntMap
instance (Data.Key.Keyed f, Data.Key.Keyed g) => Data.Key.Keyed (Data.Functor.Compose.Compose f g)
instance Data.Key.Keyed []
instance Data.Key.Keyed Control.Applicative.ZipList
instance Data.Key.Keyed GHC.Base.NonEmpty
instance Data.Key.Keyed Data.Sequence.Internal.Seq
instance Data.Key.Keyed (Data.Map.Internal.Map k)
instance GHC.Arr.Ix i => Data.Key.Keyed (GHC.Arr.Array i)
instance (Data.Key.Keyed f, Data.Key.Keyed g) => Data.Key.Keyed (Data.Functor.Sum.Sum f g)
instance (Data.Key.Keyed f, Data.Key.Keyed g) => Data.Key.Keyed (Data.Functor.Product.Product f g)
instance Data.Key.Keyed ((,) k)
instance Data.Key.Keyed (Data.HashMap.Base.HashMap k)
instance Data.Key.Keyed GHC.Maybe.Maybe
