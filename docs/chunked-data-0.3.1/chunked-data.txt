-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typeclasses for dealing with various chunked data representations
--   
--   See docs and README at
--   <a>http://www.stackage.org/package/chunked-data</a>
@package chunked-data
@version 0.3.1


-- | Abstraction for different kinds of builders.
--   
--   Note that whenever a character encoding is used, it will be UTF8. For
--   different behavior, please use the underlying library.
module Data.Builder

-- | Since 0.1.0.0
type TextBuilder = Builder

-- | Since 0.1.0.0
type BlazeBuilder = Builder

-- | Since 0.3.0.0
type ByteStringBuilder = Builder

-- | Since 0.1.0.0
class Monoid builder => Builder builder lazy | builder -> lazy, lazy -> builder

-- | Since 0.1.0.0
builderToLazy :: Builder builder lazy => builder -> lazy

-- | Since 0.1.0.0
flushBuilder :: Builder builder lazy => builder

-- | Since 0.1.0.0
class ToBuilder value builder

-- | Since 0.1.0.0
toBuilder :: ToBuilder value builder => value -> builder

-- | Provided for type disambiguation in the presence of OverloadedStrings.
--   
--   Since 0.1.0.0
textToBuilder :: ToBuilder Text builder => Text -> builder
instance Data.Builder.ToBuilder Data.Text.Internal.Builder.Builder Data.Text.Internal.Builder.Builder
instance Data.Builder.ToBuilder Data.Text.Internal.Text Data.Text.Internal.Builder.Builder
instance Data.Builder.ToBuilder Data.Text.Internal.Lazy.Text Data.Text.Internal.Builder.Builder
instance Data.Builder.ToBuilder GHC.Types.Char Data.Text.Internal.Builder.Builder
instance (a Data.Type.Equality.~ GHC.Types.Char) => Data.Builder.ToBuilder [a] Data.Text.Internal.Builder.Builder
instance Data.Builder.ToBuilder Data.ByteString.Builder.Internal.Builder Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder Data.Text.Internal.Text Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder Data.Text.Internal.Lazy.Text Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder GHC.Types.Char Data.ByteString.Builder.Internal.Builder
instance (a Data.Type.Equality.~ GHC.Types.Char) => Data.Builder.ToBuilder [a] Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder Data.ByteString.Internal.ByteString Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Builder.Internal.Builder
instance Data.Builder.Builder Data.Text.Internal.Builder.Builder Data.Text.Internal.Lazy.Text
instance Data.Builder.Builder Data.ByteString.Builder.Internal.Builder Data.ByteString.Lazy.Internal.ByteString


-- | Various zipping and unzipping functions for chunked data structures.
module Data.ChunkedZip
class Functor f => Zip f
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c
zip :: Zip f => f a -> f b -> f (a, b)
zap :: Zip f => f (a -> b) -> f a -> f b
unzip :: Zip f => f (a, b) -> (f a, f b)
class Functor f => Zip3 f
zipWith3 :: Zip3 f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
zip3 :: Zip3 f => f a -> f b -> f c -> f (a, b, c)
zap3 :: Zip3 f => f (a -> b -> c) -> f a -> f b -> f c
unzip3 :: Zip3 f => f (a, b, c) -> (f a, f b, f c)
class Functor f => Zip4 f
zipWith4 :: Zip4 f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
zip4 :: Zip4 f => f a -> f b -> f c -> f d -> f (a, b, c, d)
zap4 :: Zip4 f => f (a -> b -> c -> d) -> f a -> f b -> f c -> f d
unzip4 :: Zip4 f => f (a, b, c, d) -> (f a, f b, f c, f d)
class Functor f => Zip5 f
zipWith5 :: Zip5 f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g
zip5 :: Zip5 f => f a -> f b -> f c -> f d -> f e -> f (a, b, c, d, e)
zap5 :: Zip5 f => f (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
unzip5 :: Zip5 f => f (a, b, c, d, e) -> (f a, f b, f c, f d, f e)
class Functor f => Zip6 f
zipWith6 :: Zip6 f => (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h
zip6 :: Zip6 f => f a -> f b -> f c -> f d -> f e -> f g -> f (a, b, c, d, e, g)
zap6 :: Zip6 f => f (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g
unzip6 :: Zip6 f => f (a, b, c, d, e, g) -> (f a, f b, f c, f d, f e, f g)
class Functor f => Zip7 f
zipWith7 :: Zip7 f => (a -> b -> c -> d -> e -> g -> h -> i) -> f a -> f b -> f c -> f d -> f e -> f g -> f h -> f i
zip7 :: Zip7 f => f a -> f b -> f c -> f d -> f e -> f g -> f h -> f (a, b, c, d, e, g, h)
zap7 :: Zip7 f => f (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h
unzip7 :: Zip7 f => f (a, b, c, d, e, g, h) -> (f a, f b, f c, f d, f e, f g, f h)
instance Data.ChunkedZip.Zip7 []
instance Data.ChunkedZip.Zip6 []
instance Data.ChunkedZip.Zip6 Data.Vector.Vector
instance Data.ChunkedZip.Zip5 []
instance Data.ChunkedZip.Zip5 Data.Vector.Vector
instance Data.ChunkedZip.Zip4 []
instance Data.ChunkedZip.Zip4 Data.Vector.Vector
instance Data.ChunkedZip.Zip4 Data.Sequence.Internal.Seq
instance Data.ChunkedZip.Zip3 []
instance Data.ChunkedZip.Zip3 Data.Vector.Vector
instance Data.ChunkedZip.Zip3 Data.Sequence.Internal.Seq
instance Data.ChunkedZip.Zip []
instance Data.ChunkedZip.Zip GHC.Base.NonEmpty
instance Data.ChunkedZip.Zip Data.Sequence.Internal.Seq
instance Data.ChunkedZip.Zip Data.Tree.Tree
instance Data.ChunkedZip.Zip Data.Vector.Vector
instance Data.ChunkedZip.Zip m => Data.ChunkedZip.Zip (Control.Monad.Trans.Identity.IdentityT m)
instance Data.ChunkedZip.Zip ((->) a)
instance Data.ChunkedZip.Zip m => Data.ChunkedZip.Zip (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.ChunkedZip.Zip Data.IntMap.Internal.IntMap
instance (Data.ChunkedZip.Zip f, Data.ChunkedZip.Zip g) => Data.ChunkedZip.Zip (Data.Functor.Compose.Compose f g)

module Data.IOData

-- | Data which can be read to and from files and handles.
--   
--   Note that, for lazy sequences, these operations may perform lazy I/O.
class IOData a
readFile :: (IOData a, MonadIO m) => FilePath -> m a
writeFile :: (IOData a, MonadIO m) => FilePath -> a -> m ()
getLine :: (IOData a, MonadIO m) => m a
hGetContents :: (IOData a, MonadIO m) => Handle -> m a
hGetLine :: (IOData a, MonadIO m) => Handle -> m a
hPut :: (IOData a, MonadIO m) => Handle -> a -> m ()
hPutStrLn :: (IOData a, MonadIO m) => Handle -> a -> m ()
hGetChunk :: (IOData a, MonadIO m) => Handle -> m a
instance Data.IOData.IOData Data.ByteString.Internal.ByteString
instance Data.IOData.IOData Data.ByteString.Lazy.Internal.ByteString
instance Data.IOData.IOData Data.Text.Internal.Text
instance Data.IOData.IOData Data.Text.Internal.Lazy.Text
instance (GHC.Types.Char Data.Type.Equality.~ c) => Data.IOData.IOData [c]
