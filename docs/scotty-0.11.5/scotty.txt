-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp
--   
--   A Haskell web framework inspired by Ruby's Sinatra, using WAI and
--   Warp.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Web.Scotty
--   
--   import Data.Monoid (mconcat)
--   
--   main = scotty 3000 $
--     get "/:word" $ do
--       beam &lt;- param "word"
--       html $ mconcat ["&lt;h1&gt;Scotty, ", beam, " me up!&lt;/h1&gt;"]
--   </pre>
--   
--   Scotty is the cheap and cheerful way to write RESTful, declarative web
--   applications.
--   
--   <ul>
--   <li>A page is as simple as defining the verb, url pattern, and Text
--   content.</li>
--   <li>It is template-language agnostic. Anything that returns a Text
--   value will do.</li>
--   <li>Conforms to WAI Application interface.</li>
--   <li>Uses very fast Warp webserver by default.</li>
--   </ul>
--   
--   As for the name: Sinatra + Warp = Scotty.
--   
--   <ul>
--   <li><i>WAI</i> <a>http://hackage.haskell.org/package/wai</a></li>
--   <li><i>Warp</i> <a>http://hackage.haskell.org/package/warp</a></li>
--   </ul>
@package scotty
@version 0.11.5

module Web.Scotty.Internal.Types
data Options
Options :: Int -> Settings -> Options

-- | 0 = silent, 1(def) = startup banner
[verbose] :: Options -> Int

-- | Warp <a>Settings</a> Note: to work around an issue in warp, the
--   default FD cache duration is set to 0 so changes to static files are
--   always picked up. This likely has performance implications, so you may
--   want to modify this for production servers using
--   <tt>setFdCacheDuration</tt>.
[settings] :: Options -> Settings
type Middleware m = Application m -> Application m
type Application m = Request -> m Response
data ScottyState e m
ScottyState :: [Middleware] -> [Middleware m] -> ErrorHandler e m -> ScottyState e m
[middlewares] :: ScottyState e m -> [Middleware]
[routes] :: ScottyState e m -> [Middleware m]
[handler] :: ScottyState e m -> ErrorHandler e m
addMiddleware :: Middleware -> ScottyState e m -> ScottyState e m
addRoute :: Middleware m -> ScottyState e m -> ScottyState e m
addHandler :: ErrorHandler e m -> ScottyState e m -> ScottyState e m
newtype ScottyT e m a
ScottyT :: State (ScottyState e m) a -> ScottyT e m a
[runS] :: ScottyT e m a -> State (ScottyState e m) a
data ActionError e
Redirect :: Text -> ActionError e
Next :: ActionError e
Finish :: ActionError e
ActionError :: e -> ActionError e

-- | In order to use a custom exception type (aside from <a>Text</a>), you
--   must define an instance of <a>ScottyError</a> for that type.
class ScottyError e
stringError :: ScottyError e => String -> e
showError :: ScottyError e => e -> Text
type ErrorHandler e m = Maybe (e -> ActionT e m ())
type Param = (Text, Text)
type File = (Text, FileInfo ByteString)
data ActionEnv
Env :: Request -> [Param] -> IO ByteString -> IO ByteString -> [File] -> ActionEnv
[getReq] :: ActionEnv -> Request
[getParams] :: ActionEnv -> [Param]
[getBody] :: ActionEnv -> IO ByteString
[getBodyChunk] :: ActionEnv -> IO ByteString
[getFiles] :: ActionEnv -> [File]
data RequestBodyState
BodyUntouched :: RequestBodyState
BodyCached :: ByteString -> [ByteString] -> RequestBodyState
BodyCorrupted :: RequestBodyState
data BodyPartiallyStreamed
BodyPartiallyStreamed :: BodyPartiallyStreamed
data Content
ContentBuilder :: Builder -> Content
ContentFile :: FilePath -> Content
ContentStream :: StreamingBody -> Content
data ScottyResponse
SR :: Status -> ResponseHeaders -> Content -> ScottyResponse
[srStatus] :: ScottyResponse -> Status
[srHeaders] :: ScottyResponse -> ResponseHeaders
[srContent] :: ScottyResponse -> Content
newtype ActionT e m a
ActionT :: ExceptT (ActionError e) (ReaderT ActionEnv (StateT ScottyResponse m)) a -> ActionT e m a
[runAM] :: ActionT e m a -> ExceptT (ActionError e) (ReaderT ActionEnv (StateT ScottyResponse m)) a
data RoutePattern
Capture :: Text -> RoutePattern
Literal :: Text -> RoutePattern
Function :: (Request -> Maybe [Param]) -> RoutePattern
instance GHC.Base.Monad (Web.Scotty.Internal.Types.ScottyT e m)
instance GHC.Base.Applicative (Web.Scotty.Internal.Types.ScottyT e m)
instance GHC.Base.Functor (Web.Scotty.Internal.Types.ScottyT e m)
instance (Control.Monad.IO.Class.MonadIO m, Web.Scotty.Internal.Types.ScottyError e) => Control.Monad.IO.Class.MonadIO (Web.Scotty.Internal.Types.ActionT e m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Web.Scotty.Internal.Types.ActionT e m)
instance GHC.Base.Functor m => GHC.Base.Functor (Web.Scotty.Internal.Types.ActionT e m)
instance GHC.Show.Show Web.Scotty.Internal.Types.BodyPartiallyStreamed
instance Data.String.IsString Web.Scotty.Internal.Types.RoutePattern
instance Data.Default.Class.Default (Web.Scotty.Internal.Types.ScottyState e m)
instance (GHC.Base.Monad m, Web.Scotty.Internal.Types.ScottyError e) => GHC.Base.Monad (Web.Scotty.Internal.Types.ActionT e m)
instance (GHC.Base.Monad m, Web.Scotty.Internal.Types.ScottyError e) => Control.Monad.Fail.MonadFail (Web.Scotty.Internal.Types.ActionT e m)
instance (GHC.Base.Monad m, Web.Scotty.Internal.Types.ScottyError e) => GHC.Base.Alternative (Web.Scotty.Internal.Types.ActionT e m)
instance (GHC.Base.Monad m, Web.Scotty.Internal.Types.ScottyError e) => GHC.Base.MonadPlus (Web.Scotty.Internal.Types.ActionT e m)
instance Control.Monad.Trans.Class.MonadTrans (Web.Scotty.Internal.Types.ActionT e)
instance (Web.Scotty.Internal.Types.ScottyError e, GHC.Base.Monad m) => Control.Monad.Error.Class.MonadError (Web.Scotty.Internal.Types.ActionError e) (Web.Scotty.Internal.Types.ActionT e m)
instance (Control.Monad.Base.MonadBase b m, Web.Scotty.Internal.Types.ScottyError e) => Control.Monad.Base.MonadBase b (Web.Scotty.Internal.Types.ActionT e m)
instance (Control.Monad.Catch.MonadThrow m, Web.Scotty.Internal.Types.ScottyError e) => Control.Monad.Catch.MonadThrow (Web.Scotty.Internal.Types.ActionT e m)
instance (Control.Monad.Catch.MonadCatch m, Web.Scotty.Internal.Types.ScottyError e) => Control.Monad.Catch.MonadCatch (Web.Scotty.Internal.Types.ActionT e m)
instance Control.Monad.Trans.Control.MonadTransControl (Web.Scotty.Internal.Types.ActionT e)
instance (Web.Scotty.Internal.Types.ScottyError e, Control.Monad.Trans.Control.MonadBaseControl b m) => Control.Monad.Trans.Control.MonadBaseControl b (Web.Scotty.Internal.Types.ActionT e m)
instance Data.Default.Class.Default Web.Scotty.Internal.Types.ScottyResponse
instance GHC.Exception.Type.Exception Web.Scotty.Internal.Types.BodyPartiallyStreamed
instance Web.Scotty.Internal.Types.ScottyError Data.Text.Internal.Lazy.Text
instance Web.Scotty.Internal.Types.ScottyError e => Web.Scotty.Internal.Types.ScottyError (Web.Scotty.Internal.Types.ActionError e)
instance Data.Default.Class.Default Web.Scotty.Internal.Types.Options


-- | It should be noted that most of the code snippets below depend on the
--   OverloadedStrings language pragma.
--   
--   The functions in this module allow an arbitrary monad to be embedded
--   in Scotty's monad transformer stack in order that Scotty be combined
--   with other DSLs.
--   
--   Scotty is set up by default for development mode. For production
--   servers, you will likely want to modify <a>settings</a> and the
--   <a>defaultHandler</a>. See the comments on each of these functions for
--   more information.
module Web.Scotty.Trans

-- | Run a scotty application using the warp server. NB: scotty p ===
--   scottyT p id
scottyT :: (Monad m, MonadIO n) => Port -> (m Response -> IO Response) -> ScottyT e m () -> n ()

-- | Turn a scotty application into a WAI <a>Application</a>, which can be
--   run with any WAI handler. NB: scottyApp === scottyAppT id
scottyAppT :: (Monad m, Monad n) => (m Response -> IO Response) -> ScottyT e m () -> n Application

-- | Run a scotty application using the warp server, passing extra options.
--   NB: scottyOpts opts === scottyOptsT opts id
scottyOptsT :: (Monad m, MonadIO n) => Options -> (m Response -> IO Response) -> ScottyT e m () -> n ()

-- | Run a scotty application using the warp server, passing extra options,
--   and listening on the provided socket. NB: scottySocket opts sock ===
--   scottySocketT opts sock id
scottySocketT :: (Monad m, MonadIO n) => Options -> Socket -> (m Response -> IO Response) -> ScottyT e m () -> n ()
data Options
Options :: Int -> Settings -> Options

-- | 0 = silent, 1(def) = startup banner
[verbose] :: Options -> Int

-- | Warp <a>Settings</a> Note: to work around an issue in warp, the
--   default FD cache duration is set to 0 so changes to static files are
--   always picked up. This likely has performance implications, so you may
--   want to modify this for production servers using
--   <tt>setFdCacheDuration</tt>.
[settings] :: Options -> Settings

-- | Use given middleware. Middleware is nested such that the first
--   declared is the outermost middleware (it has first dibs on the request
--   and last action on the response). Every middleware is run on each
--   request.
middleware :: Middleware -> ScottyT e m ()

-- | get = <a>addroute</a> <a>GET</a>
get :: (ScottyError e, MonadIO m) => RoutePattern -> ActionT e m () -> ScottyT e m ()

-- | post = <a>addroute</a> <a>POST</a>
post :: (ScottyError e, MonadIO m) => RoutePattern -> ActionT e m () -> ScottyT e m ()

-- | put = <a>addroute</a> <a>PUT</a>
put :: (ScottyError e, MonadIO m) => RoutePattern -> ActionT e m () -> ScottyT e m ()

-- | delete = <a>addroute</a> <a>DELETE</a>
delete :: (ScottyError e, MonadIO m) => RoutePattern -> ActionT e m () -> ScottyT e m ()

-- | patch = <a>addroute</a> <a>PATCH</a>
patch :: (ScottyError e, MonadIO m) => RoutePattern -> ActionT e m () -> ScottyT e m ()

-- | options = <a>addroute</a> <a>OPTIONS</a>
options :: (ScottyError e, MonadIO m) => RoutePattern -> ActionT e m () -> ScottyT e m ()

-- | Define a route with a <a>StdMethod</a>, <a>Text</a> value representing
--   the path spec, and a body (<tt>Action</tt>) which modifies the
--   response.
--   
--   <pre>
--   addroute GET "/" $ text "beam me up!"
--   </pre>
--   
--   The path spec can include values starting with a colon, which are
--   interpreted as <i>captures</i>. These are named wildcards that can be
--   looked up with <a>param</a>.
--   
--   <pre>
--   addroute GET "/foo/:bar" $ do
--       v &lt;- param "bar"
--       text v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/foo/something
--   something
--   </pre>
addroute :: (ScottyError e, MonadIO m) => StdMethod -> RoutePattern -> ActionT e m () -> ScottyT e m ()

-- | Add a route that matches regardless of the HTTP verb.
matchAny :: (ScottyError e, MonadIO m) => RoutePattern -> ActionT e m () -> ScottyT e m ()

-- | Specify an action to take if nothing else is found. Note: this
--   _always_ matches, so should generally be the last route specified.
notFound :: (ScottyError e, MonadIO m) => ActionT e m () -> ScottyT e m ()

-- | Standard Sinatra-style route. Named captures are prepended with
--   colons. This is the default route type generated by OverloadedString
--   routes. i.e.
--   
--   <pre>
--   get (capture "/foo/:bar") $ ...
--   </pre>
--   
--   and
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   ...
--   get "/foo/:bar" $ ...
--   </pre>
--   
--   are equivalent.
capture :: String -> RoutePattern

-- | Match requests using a regular expression. Named captures are not yet
--   supported.
--   
--   <pre>
--   get (regex "^/f(.*)r$") $ do
--      path &lt;- param "0"
--      cap &lt;- param "1"
--      text $ mconcat ["Path: ", path, "\nCapture: ", cap]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/foo/bar
--   Path: /foo/bar
--   Capture: oo/ba
--   </pre>
regex :: String -> RoutePattern

-- | Build a route based on a function which can match using the entire
--   <a>Request</a> object. <a>Nothing</a> indicates the route does not
--   match. A <a>Just</a> value indicates a successful match, optionally
--   returning a list of key-value pairs accessible by <a>param</a>.
--   
--   <pre>
--   get (function $ \req -&gt; Just [("version", T.pack $ show $ httpVersion req)]) $ do
--       v &lt;- param "version"
--       text v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/
--   HTTP/1.1
--   </pre>
function :: (Request -> Maybe [Param]) -> RoutePattern

-- | Build a route that requires the requested path match exactly, without
--   captures.
literal :: String -> RoutePattern

-- | Get the <a>Request</a> object.
request :: Monad m => ActionT e m Request

-- | Get a request header. Header name is case-insensitive.
header :: (ScottyError e, Monad m) => Text -> ActionT e m (Maybe Text)

-- | Get all the request headers. Header names are case-insensitive.
headers :: (ScottyError e, Monad m) => ActionT e m [(Text, Text)]

-- | Get the request body.
body :: (ScottyError e, MonadIO m) => ActionT e m ByteString

-- | Get an IO action that reads body chunks
--   
--   <ul>
--   <li>This is incompatible with <a>body</a> since <a>body</a> consumes
--   all chunks.</li>
--   </ul>
bodyReader :: Monad m => ActionT e m (IO ByteString)

-- | Get a parameter. First looks in captures, then form data, then query
--   parameters.
--   
--   <ul>
--   <li>Raises an exception which can be caught by <a>rescue</a> if
--   parameter is not found.</li>
--   <li>If parameter is found, but <a>read</a> fails to parse to the
--   correct type, <a>next</a> is called. This means captures are somewhat
--   typed, in that a route won't match if a correctly typed capture cannot
--   be parsed.</li>
--   </ul>
param :: (Parsable a, ScottyError e, Monad m) => Text -> ActionT e m a

-- | Get all parameters from capture, form and query (in that order).
params :: Monad m => ActionT e m [Param]

-- | Parse the request body as a JSON object and return it. Raises an
--   exception if parse is unsuccessful.
jsonData :: (FromJSON a, ScottyError e, MonadIO m) => ActionT e m a

-- | Get list of uploaded files.
files :: Monad m => ActionT e m [File]

-- | Set the HTTP response status. Default is 200.
status :: Monad m => Status -> ActionT e m ()

-- | Add to the response headers. Header names are case-insensitive.
addHeader :: Monad m => Text -> Text -> ActionT e m ()

-- | Set one of the response headers. Will override any previously set
--   value for that header. Header names are case-insensitive.
setHeader :: Monad m => Text -> Text -> ActionT e m ()

-- | Redirect to given URL. Like throwing an uncatchable exception. Any
--   code after the call to redirect will not be run.
--   
--   <pre>
--   redirect "http://www.google.com"
--   </pre>
--   
--   OR
--   
--   <pre>
--   redirect "/foo/bar"
--   </pre>
redirect :: (ScottyError e, Monad m) => Text -> ActionT e m a

-- | Set the body of the response to the given <a>Text</a> value. Also sets
--   "Content-Type" header to "text/plain; charset=utf-8" if it has not
--   already been set.
text :: (ScottyError e, Monad m) => Text -> ActionT e m ()

-- | Set the body of the response to the given <a>Text</a> value. Also sets
--   "Content-Type" header to "text/html; charset=utf-8" if it has not
--   already been set.
html :: (ScottyError e, Monad m) => Text -> ActionT e m ()

-- | Send a file as the response. Doesn't set the "Content-Type" header, so
--   you probably want to do that on your own with <a>setHeader</a>.
file :: Monad m => FilePath -> ActionT e m ()

-- | Set the body of the response to the JSON encoding of the given value.
--   Also sets "Content-Type" header to "application/json; charset=utf-8"
--   if it has not already been set.
json :: (ToJSON a, ScottyError e, Monad m) => a -> ActionT e m ()

-- | Set the body of the response to a Source. Doesn't set the
--   "Content-Type" header, so you probably want to do that on your own
--   with <a>setHeader</a>.
stream :: Monad m => StreamingBody -> ActionT e m ()

-- | Set the body of the response to the given <a>ByteString</a> value.
--   Doesn't set the "Content-Type" header, so you probably want to do that
--   on your own with <a>setHeader</a>.
raw :: Monad m => ByteString -> ActionT e m ()

-- | Throw an exception, which can be caught with <a>rescue</a>. Uncaught
--   exceptions turn into HTTP 500 responses.
raise :: (ScottyError e, Monad m) => e -> ActionT e m a

-- | Catch an exception thrown by <a>raise</a>.
--   
--   <pre>
--   raise "just kidding" `rescue` (\msg -&gt; text msg)
--   </pre>
rescue :: (ScottyError e, Monad m) => ActionT e m a -> (e -> ActionT e m a) -> ActionT e m a

-- | Abort execution of this action and continue pattern matching routes.
--   Like an exception, any code after <a>next</a> is not executed.
--   
--   As an example, these two routes overlap. The only way the second one
--   will ever run is if the first one calls <a>next</a>.
--   
--   <pre>
--   get "/foo/:bar" $ do
--     w :: Text &lt;- param "bar"
--     unless (w == "special") next
--     text "You made a request to /foo/special"
--   
--   get "/foo/:baz" $ do
--     w &lt;- param "baz"
--     text $ "You made a request to: " &lt;&gt; w
--   </pre>
next :: (ScottyError e, Monad m) => ActionT e m a

-- | Finish the execution of the current action. Like throwing an
--   uncatchable exception. Any code after the call to finish will not be
--   run.
--   
--   <i>Since: 0.10.3</i>
finish :: (ScottyError e, Monad m) => ActionT e m a

-- | Global handler for uncaught exceptions.
--   
--   Uncaught exceptions normally become 500 responses. You can use this to
--   selectively override that behavior.
--   
--   Note: IO exceptions are lifted into <a>ScottyError</a>s by
--   <a>stringError</a>. This has security implications, so you probably
--   want to provide your own defaultHandler in production which does not
--   send out the error strings as 500 responses.
defaultHandler :: (ScottyError e, Monad m) => (e -> ActionT e m ()) -> ScottyT e m ()

-- | In order to use a custom exception type (aside from <a>Text</a>), you
--   must define an instance of <a>ScottyError</a> for that type.
class ScottyError e
stringError :: ScottyError e => String -> e
showError :: ScottyError e => e -> Text

-- | Like <a>liftIO</a>, but catch any IO exceptions and turn them into
--   <a>ScottyError</a>s.
liftAndCatchIO :: (ScottyError e, MonadIO m) => IO a -> ActionT e m a
type Param = (Text, Text)

-- | Minimum implemention: <a>parseParam</a>
class Parsable a

-- | Take a <a>Text</a> value and parse it as <tt>a</tt>, or fail with a
--   message.
parseParam :: Parsable a => Text -> Either Text a

-- | Default implementation parses comma-delimited lists.
--   
--   <pre>
--   parseParamList t = mapM parseParam (T.split (== ',') t)
--   </pre>
parseParamList :: Parsable a => Text -> Either Text [a]

-- | Useful for creating <a>Parsable</a> instances for things that already
--   implement <a>Read</a>. Ex:
--   
--   <pre>
--   instance Parsable Int where parseParam = readEither
--   </pre>
readEither :: Read a => Text -> Either Text a
data RoutePattern
type File = (Text, FileInfo ByteString)
data ScottyT e m a
data ActionT e m a


-- | It should be noted that most of the code snippets below depend on the
--   OverloadedStrings language pragma.
--   
--   Scotty is set up by default for development mode. For production
--   servers, you will likely want to modify <a>settings</a> and the
--   <a>defaultHandler</a>. See the comments on each of these functions for
--   more information.
module Web.Scotty

-- | Run a scotty application using the warp server.
scotty :: Port -> ScottyM () -> IO ()

-- | Turn a scotty application into a WAI <a>Application</a>, which can be
--   run with any WAI handler.
scottyApp :: ScottyM () -> IO Application

-- | Run a scotty application using the warp server, passing extra options.
scottyOpts :: Options -> ScottyM () -> IO ()

-- | Run a scotty application using the warp server, passing extra options,
--   and listening on the provided socket. This allows the user to provide,
--   for example, a Unix named socket, which can be used when reverse HTTP
--   proxying into your application.
scottySocket :: Options -> Socket -> ScottyM () -> IO ()
data Options
Options :: Int -> Settings -> Options

-- | 0 = silent, 1(def) = startup banner
[verbose] :: Options -> Int

-- | Warp <a>Settings</a> Note: to work around an issue in warp, the
--   default FD cache duration is set to 0 so changes to static files are
--   always picked up. This likely has performance implications, so you may
--   want to modify this for production servers using
--   <tt>setFdCacheDuration</tt>.
[settings] :: Options -> Settings

-- | Use given middleware. Middleware is nested such that the first
--   declared is the outermost middleware (it has first dibs on the request
--   and last action on the response). Every middleware is run on each
--   request.
middleware :: Middleware -> ScottyM ()

-- | get = <a>addroute</a> <tt>GET</tt>
get :: RoutePattern -> ActionM () -> ScottyM ()

-- | post = <a>addroute</a> <tt>POST</tt>
post :: RoutePattern -> ActionM () -> ScottyM ()

-- | put = <a>addroute</a> <tt>PUT</tt>
put :: RoutePattern -> ActionM () -> ScottyM ()

-- | delete = <a>addroute</a> <tt>DELETE</tt>
delete :: RoutePattern -> ActionM () -> ScottyM ()

-- | patch = <a>addroute</a> <tt>PATCH</tt>
patch :: RoutePattern -> ActionM () -> ScottyM ()

-- | options = <a>addroute</a> <tt>OPTIONS</tt>
options :: RoutePattern -> ActionM () -> ScottyM ()

-- | Define a route with a <a>StdMethod</a>, <a>Text</a> value representing
--   the path spec, and a body (<tt>Action</tt>) which modifies the
--   response.
--   
--   <pre>
--   addroute GET "/" $ text "beam me up!"
--   </pre>
--   
--   The path spec can include values starting with a colon, which are
--   interpreted as <i>captures</i>. These are named wildcards that can be
--   looked up with <a>param</a>.
--   
--   <pre>
--   addroute GET "/foo/:bar" $ do
--       v &lt;- param "bar"
--       text v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/foo/something
--   something
--   </pre>
addroute :: StdMethod -> RoutePattern -> ActionM () -> ScottyM ()

-- | Add a route that matches regardless of the HTTP verb.
matchAny :: RoutePattern -> ActionM () -> ScottyM ()

-- | Specify an action to take if nothing else is found. Note: this
--   _always_ matches, so should generally be the last route specified.
notFound :: ActionM () -> ScottyM ()

-- | Standard Sinatra-style route. Named captures are prepended with
--   colons. This is the default route type generated by OverloadedString
--   routes. i.e.
--   
--   <pre>
--   get (capture "/foo/:bar") $ ...
--   </pre>
--   
--   and
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   ...
--   get "/foo/:bar" $ ...
--   </pre>
--   
--   are equivalent.
capture :: String -> RoutePattern

-- | Match requests using a regular expression. Named captures are not yet
--   supported.
--   
--   <pre>
--   get (regex "^/f(.*)r$") $ do
--      path &lt;- param "0"
--      cap &lt;- param "1"
--      text $ mconcat ["Path: ", path, "\nCapture: ", cap]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/foo/bar
--   Path: /foo/bar
--   Capture: oo/ba
--   </pre>
regex :: String -> RoutePattern

-- | Build a route based on a function which can match using the entire
--   <a>Request</a> object. <a>Nothing</a> indicates the route does not
--   match. A <a>Just</a> value indicates a successful match, optionally
--   returning a list of key-value pairs accessible by <a>param</a>.
--   
--   <pre>
--   get (function $ \req -&gt; Just [("version", pack $ show $ httpVersion req)]) $ do
--       v &lt;- param "version"
--       text v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; curl http://localhost:3000/
--   HTTP/1.1
--   </pre>
function :: (Request -> Maybe [Param]) -> RoutePattern

-- | Build a route that requires the requested path match exactly, without
--   captures.
literal :: String -> RoutePattern

-- | Get the <a>Request</a> object.
request :: ActionM Request

-- | Get a request header. Header name is case-insensitive.
header :: Text -> ActionM (Maybe Text)

-- | Get all the request headers. Header names are case-insensitive.
headers :: ActionM [(Text, Text)]

-- | Get the request body.
body :: ActionM ByteString

-- | Get an IO action that reads body chunks
--   
--   <ul>
--   <li>This is incompatible with <a>body</a> since <a>body</a> consumes
--   all chunks.</li>
--   </ul>
bodyReader :: ActionM (IO ByteString)

-- | Get a parameter. First looks in captures, then form data, then query
--   parameters.
--   
--   <ul>
--   <li>Raises an exception which can be caught by <a>rescue</a> if
--   parameter is not found.</li>
--   <li>If parameter is found, but <a>read</a> fails to parse to the
--   correct type, <a>next</a> is called. This means captures are somewhat
--   typed, in that a route won't match if a correctly typed capture cannot
--   be parsed.</li>
--   </ul>
param :: Parsable a => Text -> ActionM a

-- | Get all parameters from capture, form and query (in that order).
params :: ActionM [Param]

-- | Parse the request body as a JSON object and return it. Raises an
--   exception if parse is unsuccessful.
jsonData :: FromJSON a => ActionM a

-- | Get list of uploaded files.
files :: ActionM [File]

-- | Set the HTTP response status. Default is 200.
status :: Status -> ActionM ()

-- | Add to the response headers. Header names are case-insensitive.
addHeader :: Text -> Text -> ActionM ()

-- | Set one of the response headers. Will override any previously set
--   value for that header. Header names are case-insensitive.
setHeader :: Text -> Text -> ActionM ()

-- | Redirect to given URL. Like throwing an uncatchable exception. Any
--   code after the call to redirect will not be run.
--   
--   <pre>
--   redirect "http://www.google.com"
--   </pre>
--   
--   OR
--   
--   <pre>
--   redirect "/foo/bar"
--   </pre>
redirect :: Text -> ActionM a

-- | Set the body of the response to the given <a>Text</a> value. Also sets
--   "Content-Type" header to "text/plain; charset=utf-8" if it has not
--   already been set.
text :: Text -> ActionM ()

-- | Set the body of the response to the given <a>Text</a> value. Also sets
--   "Content-Type" header to "text/html; charset=utf-8" if it has not
--   already been set.
html :: Text -> ActionM ()

-- | Send a file as the response. Doesn't set the "Content-Type" header, so
--   you probably want to do that on your own with <a>setHeader</a>.
file :: FilePath -> ActionM ()

-- | Set the body of the response to the JSON encoding of the given value.
--   Also sets "Content-Type" header to "application/json; charset=utf-8"
--   if it has not already been set.
json :: ToJSON a => a -> ActionM ()

-- | Set the body of the response to a StreamingBody. Doesn't set the
--   "Content-Type" header, so you probably want to do that on your own
--   with <a>setHeader</a>.
stream :: StreamingBody -> ActionM ()

-- | Set the body of the response to the given <a>ByteString</a> value.
--   Doesn't set the "Content-Type" header, so you probably want to do that
--   on your own with <a>setHeader</a>.
raw :: ByteString -> ActionM ()

-- | Throw an exception, which can be caught with <a>rescue</a>. Uncaught
--   exceptions turn into HTTP 500 responses.
raise :: Text -> ActionM a

-- | Catch an exception thrown by <a>raise</a>.
--   
--   <pre>
--   raise "just kidding" `rescue` (\msg -&gt; text msg)
--   </pre>
rescue :: ActionM a -> (Text -> ActionM a) -> ActionM a

-- | Abort execution of this action and continue pattern matching routes.
--   Like an exception, any code after <a>next</a> is not executed.
--   
--   As an example, these two routes overlap. The only way the second one
--   will ever run is if the first one calls <a>next</a>.
--   
--   <pre>
--   get "/foo/:bar" $ do
--     w :: Text &lt;- param "bar"
--     unless (w == "special") next
--     text "You made a request to /foo/special"
--   
--   get "/foo/:baz" $ do
--     w &lt;- param "baz"
--     text $ "You made a request to: " &lt;&gt; w
--   </pre>
next :: ActionM a

-- | Abort execution of this action. Like an exception, any code after
--   <a>finish</a> is not executed.
--   
--   As an example only requests to <tt>/foo/special</tt> will include in
--   the response content the text message.
--   
--   <pre>
--   get "/foo/:bar" $ do
--     w :: Text &lt;- param "bar"
--     unless (w == "special") finish
--     text "You made a request to /foo/special"
--   </pre>
--   
--   <i>Since: 0.10.3</i>
finish :: ActionM a

-- | Global handler for uncaught exceptions.
--   
--   Uncaught exceptions normally become 500 responses. You can use this to
--   selectively override that behavior.
--   
--   Note: IO exceptions are lifted into Scotty exceptions by default. This
--   has security implications, so you probably want to provide your own
--   defaultHandler in production which does not send out the error strings
--   as 500 responses.
defaultHandler :: (Text -> ActionM ()) -> ScottyM ()

-- | Like <tt>liftIO</tt>, but catch any IO exceptions and turn them into
--   Scotty exceptions.
liftAndCatchIO :: IO a -> ActionM a
type Param = (Text, Text)

-- | Minimum implemention: <a>parseParam</a>
class Parsable a

-- | Take a <a>Text</a> value and parse it as <tt>a</tt>, or fail with a
--   message.
parseParam :: Parsable a => Text -> Either Text a

-- | Default implementation parses comma-delimited lists.
--   
--   <pre>
--   parseParamList t = mapM parseParam (T.split (== ',') t)
--   </pre>
parseParamList :: Parsable a => Text -> Either Text [a]

-- | Useful for creating <a>Parsable</a> instances for things that already
--   implement <a>Read</a>. Ex:
--   
--   <pre>
--   instance Parsable Int where parseParam = readEither
--   </pre>
readEither :: Read a => Text -> Either Text a
type ScottyM = ScottyT Text IO
type ActionM = ActionT Text IO
data RoutePattern
type File = (Text, FileInfo ByteString)
