-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe EDSL for SQL queries on persistent backends.
--   
--   <tt>esqueleto</tt> is a bare bones, type-safe EDSL for SQL queries
--   that works with unmodified <tt>persistent</tt> SQL backends. Its
--   language closely resembles SQL, so you don't have to learn new
--   concepts, just new syntax, and it's fairly easy to predict the
--   generated SQL and optimize it for your backend. Most kinds of errors
--   committed when writing SQL are caught as compile-time
--   errors---although it is possible to write type-checked
--   <tt>esqueleto</tt> queries that fail at runtime.
--   
--   <tt>persistent</tt> is a library for type-safe data serialization. It
--   has many kinds of backends, such as SQL backends
--   (<tt>persistent-mysql</tt>, <tt>persistent-postgresql</tt>,
--   <tt>persistent-sqlite</tt>) and NoSQL backends
--   (<tt>persistent-mongoDB</tt>). While <tt>persistent</tt> is a nice
--   library for storing and retrieving records, including with filters, it
--   does not try to support some of the features that are specific to SQL
--   backends. In particular, <tt>esqueleto</tt> is the recommended library
--   for type-safe <tt>JOIN</tt>s on <tt>persistent</tt> SQL backends. (The
--   alternative is using raw SQL, but that's error prone and does not
--   offer any composability.)
--   
--   Currently, <tt>SELECT</tt>s, <tt>UPDATE</tt>s, <tt>INSERT</tt>s and
--   <tt>DELETE</tt>s are supported. Not all SQL features are available,
--   but most of them can be easily added (especially functions), so please
--   open an issue or send a pull request if you need anything that is not
--   covered by <tt>esqueleto</tt> on
--   <a>https://github.com/bitemyapp/esqueleto</a>.
--   
--   The name of this library means "skeleton" in Portuguese and contains
--   all three SQL letters in the correct order =). It was inspired by
--   Scala's Squeryl but created from scratch.
@package esqueleto
@version 3.0.0


-- | This is an internal module, anything exported by this module may
--   change without a major version bump. Please use only
--   <a>Database.Esqueleto</a> if possible.
module Database.Esqueleto.Internal.Language

-- | <tt>FROM</tt> clause: bring entities into scope.
--   
--   This function internally uses two type classes in order to provide
--   some flexibility of how you may call it. Internally we refer to these
--   type classes as the two different magics.
--   
--   The innermost magic allows you to use <tt>from</tt> with the following
--   types:
--   
--   <ul>
--   <li><tt>expr (Entity val)</tt>, which brings a single entity into
--   scope.</li>
--   <li><tt>expr (Maybe (Entity val))</tt>, which brings a single entity
--   that may be <tt>NULL</tt> into scope. Used for <tt>OUTER
--   JOIN</tt>s.</li>
--   <li>A <tt>JOIN</tt> of any other two types allowed by the innermost
--   magic, where a <tt>JOIN</tt> may be an <a>InnerJoin</a>, a
--   <a>CrossJoin</a>, a <a>LeftOuterJoin</a>, a <a>RightOuterJoin</a>, or
--   a <a>FullOuterJoin</a>. The <tt>JOINs</tt> have left fixity.</li>
--   </ul>
--   
--   The outermost magic allows you to use <tt>from</tt> on any tuples of
--   types supported by innermost magic (and also tuples of tuples, and so
--   on), up to 8-tuples.
--   
--   Note that using <tt>from</tt> for the same entity twice does work and
--   corresponds to a self-join. You don't even need to use two different
--   calls to <tt>from</tt>, you may use a <tt>JOIN</tt> or a tuple.
--   
--   The following are valid examples of uses of <tt>from</tt> (the types
--   of the arguments of the lambda are inside square brackets):
--   
--   <pre>
--   <a>from</a> $ \person -&gt; ...
--   <a>from</a> $ \(person, blogPost) -&gt; ...
--   <a>from</a> $ \(p `<a>LeftOuterJoin</a>` mb) -&gt; ...
--   <a>from</a> $ \(p1 `<a>InnerJoin</a>` f `<a>InnerJoin</a>` p2) -&gt; ...
--   <a>from</a> $ \((p1 `<a>InnerJoin</a>` f) `<a>InnerJoin</a>` p2) -&gt; ...
--   </pre>
--   
--   The types of the arguments to the lambdas above are, respectively:
--   
--   <pre>
--   person
--     :: ( Esqueleto query expr backend
--        , PersistEntity Person
--        , PersistEntityBackend Person ~ backend
--        ) =&gt; expr (Entity Person)
--   (person, blogPost)
--     :: (...) =&gt; (expr (Entity Person), expr (Entity BlogPost))
--   (p `<a>LeftOuterJoin</a>` mb)
--     :: (...) =&gt; InnerJoin (expr (Entity Person)) (expr (Maybe (Entity BlogPost)))
--   (p1 `<a>InnerJoin</a>` f `<a>InnerJoin</a>` p2)
--     :: (...) =&gt; InnerJoin
--                   (InnerJoin (expr (Entity Person))
--                              (expr (Entity Follow)))
--                   (expr (Entity Person))
--   (p1 `<a>InnerJoin</a>` (f `<a>InnerJoin</a>` p2)) ::
--     :: (...) =&gt; InnerJoin
--                   (expr (Entity Person))
--                   (InnerJoin (expr (Entity Follow))
--                              (expr (Entity Person)))
--   </pre>
--   
--   Note that some backends may not support all kinds of <tt>JOIN</tt>s.
from :: From a => (a -> SqlQuery b) -> SqlQuery b

-- | A single value (as opposed to a whole entity). You may use
--   <tt>(<a>^.</a>)</tt> or <tt>(<a>?.</a>)</tt> to get a <a>Value</a>
--   from an <a>Entity</a>.
newtype Value a
Value :: a -> Value a
[unValue] :: Value a -> a

-- | A list of single values. There's a limited set of functions able to
--   work with this data type (such as <a>subList_select</a>,
--   <a>valList</a>, <a>in_</a> and <a>exists</a>).
newtype ValueList a
ValueList :: a -> ValueList a

-- | A wrapper type for for any <tt>expr (Value a)</tt> for all a.
data SomeValue
[SomeValue] :: SqlExpr (Value a) -> SomeValue

-- | A class of things that can be converted into a list of SomeValue. It
--   has instances for tuples and is the reason why <a>groupBy</a> can take
--   tuples, like <tt><a>groupBy</a> (foo <a>^.</a> FooId, foo <a>^.</a>
--   FooName, foo <a>^.</a> FooType)</tt>.
class ToSomeValues a
toSomeValues :: ToSomeValues a => a -> [SomeValue]

-- | Data type that represents an <tt>INNER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data InnerJoin a b
InnerJoin :: a -> b -> InnerJoin a b
infixl 2 `InnerJoin`
infixl 2 `InnerJoin`

-- | Data type that represents a <tt>CROSS JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data CrossJoin a b
CrossJoin :: a -> b -> CrossJoin a b
infixl 2 `CrossJoin`
infixl 2 `CrossJoin`

-- | Data type that represents a <tt>LEFT OUTER JOIN</tt>. For example,
--   
--   <pre>
--   select $
--   <a>from</a> $ \(person `<a>LeftOuterJoin</a>` pet) -&gt;
--     ...
--   </pre>
--   
--   is translated into
--   
--   <pre>
--   SELECT ...
--   FROM Person LEFT OUTER JOIN Pet
--   ...
--   </pre>
--   
--   See also: <a>from</a>.
data LeftOuterJoin a b
LeftOuterJoin :: a -> b -> LeftOuterJoin a b
infixl 2 `LeftOuterJoin`
infixl 2 `LeftOuterJoin`

-- | Data type that represents a <tt>RIGHT OUTER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data RightOuterJoin a b
RightOuterJoin :: a -> b -> RightOuterJoin a b
infixl 2 `RightOuterJoin`
infixl 2 `RightOuterJoin`

-- | Data type that represents a <tt>FULL OUTER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data FullOuterJoin a b
FullOuterJoin :: a -> b -> FullOuterJoin a b
infixl 2 `FullOuterJoin`
infixl 2 `FullOuterJoin`

-- | Exception thrown whenever <a>on</a> is used to create an <tt>ON</tt>
--   clause but no matching <tt>JOIN</tt> is found.
data OnClauseWithoutMatchingJoinException
OnClauseWithoutMatchingJoinException :: String -> OnClauseWithoutMatchingJoinException

-- | Phantom type used by <a>orderBy</a>, <a>asc</a> and <a>desc</a>.
data OrderBy

-- | Phantom type used by <a>distinctOn</a> and <a>don</a>.
data DistinctOn

-- | Phantom type for a <tt>SET</tt> operation on an entity of the given
--   type (see <a>set</a> and '(=.)').
data Update typ

-- | Phantom type used by <a>insertSelect</a>.
data Insertion a

-- | Different kinds of locking clauses supported by <a>locking</a>.
--   
--   Note that each RDBMS has different locking support. The constructors
--   of this datatype specify only the <i>syntax</i> of the locking
--   mechanism, not its <i>semantics</i>. For example, even though both
--   MySQL and PostgreSQL support <a>ForUpdate</a>, there are no guarantees
--   that they will behave the same.
--   
--   <i>Since: 2.2.7</i>
data LockingKind

-- | <tt>FOR UPDATE</tt> syntax. Supported by MySQL, Oracle and PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForUpdate :: LockingKind

-- | <tt>FOR UPDATE SKIP LOCKED</tt> syntax. Supported by MySQL, Oracle and
--   PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForUpdateSkipLocked :: LockingKind

-- | <tt>FOR SHARE</tt> syntax. Supported by PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForShare :: LockingKind

-- | <tt>LOCK IN SHARE MODE</tt> syntax. Supported by MySQL.
--   
--   <i>Since: 2.2.7</i>
LockInShareMode :: LockingKind

-- | Phantom class of data types that are treated as strings by the RDBMS.
--   It has no methods because it's only used to avoid type errors such as
--   trying to concatenate integers.
--   
--   If you have a custom data type or <tt>newtype</tt>, feel free to make
--   it an instance of this class.
--   
--   <i>Since: 2.4.0</i>
class PersistField a => SqlString a

-- | Class that enables one to use <a>toBaseId</a> to convert an entity's
--   key on a query into another (cf. <a>toBaseId</a>).
class ToBaseId ent where {
    type family BaseEnt ent :: *;
}
toBaseIdWitness :: ToBaseId ent => Key (BaseEnt ent) -> Key ent

-- | (Internal) A kind of <tt>JOIN</tt>.
data JoinKind

-- | <pre>
--   INNER JOIN
--   </pre>
InnerJoinKind :: JoinKind

-- | <pre>
--   CROSS JOIN
--   </pre>
CrossJoinKind :: JoinKind

-- | <pre>
--   LEFT OUTER JOIN
--   </pre>
LeftOuterJoinKind :: JoinKind

-- | <pre>
--   RIGHT OUTER JOIN
--   </pre>
RightOuterJoinKind :: JoinKind

-- | <pre>
--   FULL OUTER JOIN
--   </pre>
FullOuterJoinKind :: JoinKind

-- | (Internal) Functions that operate on types (that should be) of kind
--   <a>JoinKind</a>.
class IsJoinKind join

-- | (Internal) <tt>smartJoin a b</tt> is a <tt>JOIN</tt> of the correct
--   kind.
smartJoin :: IsJoinKind join => a -> b -> join a b

-- | (Internal) Reify a <tt>JoinKind</tt> from a <tt>JOIN</tt>. This
--   function is non-strict.
reifyJoinKind :: IsJoinKind join => join a b -> JoinKind

-- | This class witnesses that two backend are compatible, and that you can
--   convert from the <tt>sub</tt> backend into the <tt>sup</tt> backend.
--   This is similar to the <a>HasPersistBackend</a> and
--   <a>IsPersistBackend</a> classes, but where you don't want to fix the
--   type associated with the <a>PersistEntityBackend</a> of a record.
--   
--   Generally speaking, where you might have:
--   
--   <pre>
--   foo ::
--     ( <a>PersistEntity</a> record
--     , <tt>PeristEntityBackend</tt> record ~ <a>BaseBackend</a> backend
--     , <tt>IsSqlBackend</tt> backend
--     )
--   </pre>
--   
--   this can be replaced with:
--   
--   <pre>
--   foo ::
--     ( <a>PersistEntity</a> record,
--     , <a>PersistEntityBackend</a> record ~ backend
--     , <a>BackendCompatible</a> <tt>SqlBackend</tt> backend
--     )
--   </pre>
--   
--   This works for <tt>SqlReadBackend</tt> because of the <tt>instance
--   <a>BackendCompatible</a> <tt>SqlBackend</tt>
--   <tt>SqlReadBackend</tt></tt>, without needing to go through the
--   <a>BaseBackend</a> type family.
--   
--   Likewise, functions that are currently hardcoded to use
--   <tt>SqlBackend</tt> can be generalized:
--   
--   <pre>
--   -- before:
--   asdf :: <a>ReaderT</a> <tt>SqlBackend</tt> m ()
--   asdf = pure ()
--   
--   -- after:
--   asdf' :: <a>BackendCompatible</a> SqlBackend backend =&gt; ReaderT backend m ()
--   asdf' = withReaderT <a>projectBackend</a> asdf
--   </pre>
class BackendCompatible sup sub
projectBackend :: BackendCompatible sup sub => sub -> sup

-- | (Internal) Phantom type used to process <a>from</a> (see
--   <a>fromStart</a>).
data PreprocessedFrom a

-- | (Internal) Class that implements the tuple <a>from</a> magic (see
--   <a>fromStart</a>).
class From a

-- | (Internal) Class that implements the <tt>JOIN</tt> <a>from</a> magic
--   (see <a>fromStart</a>).
class FromPreprocess a

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
when_ :: expr (Value Bool) -> () -> expr a -> (expr (Value Bool), expr a)

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
then_ :: ()

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
else_ :: expr a -> expr a

-- | <tt>WHERE</tt> clause: restrict the query's result.
where_ :: SqlExpr (Value Bool) -> SqlQuery ()

-- | <tt>ON</tt> clause: restrict the a <tt>JOIN</tt>'s result. The
--   <tt>ON</tt> clause will be applied to the <i>last</i> <tt>JOIN</tt>
--   that does not have an <tt>ON</tt> clause yet. If there are no
--   <tt>JOIN</tt>s without <tt>ON</tt> clauses (either because you didn't
--   do any <tt>JOIN</tt>, or because all <tt>JOIN</tt>s already have their
--   own <tt>ON</tt> clauses), a runtime exception
--   <a>OnClauseWithoutMatchingJoinException</a> is thrown. <tt>ON</tt>
--   clauses are optional when doing <tt>JOIN</tt>s.
--   
--   On the simple case of doing just one <tt>JOIN</tt>, for example
--   
--   <pre>
--   select $
--   <a>from</a> $ \(foo `<a>InnerJoin</a>` bar) -&gt; do
--     <a>on</a> (foo <a>^.</a> FooId <a>==.</a> bar <a>^.</a> BarFooId)
--     ...
--   </pre>
--   
--   there's no ambiguity and the rules above just mean that you're allowed
--   to call <a>on</a> only once (as in SQL). If you have many joins, then
--   the <a>on</a>s are applied on the <i>reverse</i> order that the
--   <tt>JOIN</tt>s appear. For example:
--   
--   <pre>
--   select $
--   <a>from</a> $ \(foo `<a>InnerJoin</a>` bar `<a>InnerJoin</a>` baz) -&gt; do
--     <a>on</a> (baz <a>^.</a> BazId <a>==.</a> bar <a>^.</a> BarBazId)
--     <a>on</a> (foo <a>^.</a> FooId <a>==.</a> bar <a>^.</a> BarFooId)
--     ...
--   </pre>
--   
--   The order is <i>reversed</i> in order to improve composability. For
--   example, consider <tt>query1</tt> and <tt>query2</tt> below:
--   
--   <pre>
--   let query1 =
--         <a>from</a> $ \(foo `<a>InnerJoin</a>` bar) -&gt; do
--           <a>on</a> (foo <a>^.</a> FooId <a>==.</a> bar <a>^.</a> BarFooId)
--       query2 =
--         <a>from</a> $ \(mbaz `<a>LeftOuterJoin</a>` quux) -&gt; do
--           return (mbaz <a>?.</a> BazName, quux)
--       test1 =      (,) &lt;$&gt; query1 &lt;*&gt; query2
--       test2 = flip (,) &lt;$&gt; query2 &lt;*&gt; query1
--   </pre>
--   
--   If the order was <i>not</i> reversed, then <tt>test2</tt> would be
--   broken: <tt>query1</tt>'s <a>on</a> would refer to <tt>query2</tt>'s
--   <a>LeftOuterJoin</a>.
on :: SqlExpr (Value Bool) -> SqlQuery ()

-- | <tt>GROUP BY</tt> clause. You can enclose multiple columns in a tuple.
--   
--   <pre>
--   select $ <a>from</a> \(foo `<a>InnerJoin</a>` bar) -&gt; do
--     <a>on</a> (foo <a>^.</a> FooBarId <a>==.</a> bar <a>^.</a> BarId)
--     <a>groupBy</a> (bar <a>^.</a> BarId, bar <a>^.</a> BarName)
--     return (bar <a>^.</a> BarId, bar <a>^.</a> BarName, countRows)
--   </pre>
--   
--   With groupBy you can sort by aggregate functions, like so (we used
--   <tt>let</tt> to restrict the more general <a>countRows</a> to
--   <tt>SqlSqlExpr (Value Int)</tt> to avoid ambiguity---the second use of
--   <a>countRows</a> has its type restricted by the <tt>:: Int</tt>
--   below):
--   
--   <pre>
--   r &lt;- select $ <a>from</a> \(foo `<a>InnerJoin</a>` bar) -&gt; do
--     <a>on</a> (foo <a>^.</a> FooBarId <a>==.</a> bar <a>^.</a> BarId)
--     <a>groupBy</a> $ bar <a>^.</a> BarName
--     let countRows' = <a>countRows</a>
--     <a>orderBy</a> [<a>asc</a> countRows']
--     return (bar <a>^.</a> BarName, countRows')
--   forM_ r $ \(<a>Value</a> name, <a>Value</a> count) -&gt; do
--     print name
--     print (count :: Int)
--   </pre>
groupBy :: ToSomeValues a => a -> SqlQuery ()

-- | <tt>ORDER BY</tt> clause. See also <a>asc</a> and <a>desc</a>.
--   
--   Multiple calls to <a>orderBy</a> get concatenated on the final query,
--   including <a>distinctOnOrderBy</a>.
orderBy :: [SqlExpr OrderBy] -> SqlQuery ()

-- | <tt>ORDER BY random()</tt> clause.
--   
--   <i>Since: 1.3.10</i>

-- | <i>Deprecated: Since 2.6.0: <a>rand</a> ordering function is not
--   uniform across all databases! To avoid accidental partiality it will
--   be removed in the next major version.</i>
rand :: SqlExpr OrderBy

-- | Ascending order of this field or SqlExpression.
asc :: PersistField a => SqlExpr (Value a) -> SqlExpr OrderBy

-- | Descending order of this field or SqlExpression.
desc :: PersistField a => SqlExpr (Value a) -> SqlExpr OrderBy

-- | <tt>LIMIT</tt>. Limit the number of returned rows.
limit :: Int64 -> SqlQuery ()

-- | <tt>OFFSET</tt>. Usually used with <a>limit</a>.
offset :: Int64 -> SqlQuery ()

-- | <tt>DISTINCT</tt>. Change the current <tt>SELECT</tt> into <tt>SELECT
--   DISTINCT</tt>. For example:
--   
--   <pre>
--   select $ distinct $
--     <a>from</a> \foo -&gt; do
--     ...
--   </pre>
--   
--   Note that this also has the same effect:
--   
--   <pre>
--   select $
--     <a>from</a> \foo -&gt; do
--     distinct (return ())
--     ...
--   </pre>
--   
--   <i>Since: 2.2.4</i>
distinct :: SqlQuery a -> SqlQuery a

-- | <tt>DISTINCT ON</tt>. Change the current <tt>SELECT</tt> into
--   <tt>SELECT DISTINCT ON (SqlExpressions)</tt>. For example:
--   
--   <pre>
--   select $
--     <a>from</a> \foo -&gt;
--     <a>distinctOn</a> [<a>don</a> (foo ^. FooName), <a>don</a> (foo ^. FooState)] $ do
--     ...
--   </pre>
--   
--   You can also chain different calls to <a>distinctOn</a>. The above is
--   equivalent to:
--   
--   <pre>
--   select $
--     <a>from</a> \foo -&gt;
--     <a>distinctOn</a> [<a>don</a> (foo ^. FooName)] $
--     <a>distinctOn</a> [<a>don</a> (foo ^. FooState)] $ do
--     ...
--   </pre>
--   
--   Each call to <a>distinctOn</a> adds more SqlExpressions. Calls to
--   <a>distinctOn</a> override any calls to <a>distinct</a>.
--   
--   Note that PostgreSQL requires the SqlExpressions on <tt>DISTINCT
--   ON</tt> to be the first ones to appear on a <tt>ORDER BY</tt>. This is
--   not managed automatically by esqueleto, keeping its spirit of trying
--   to be close to raw SQL.
--   
--   Supported by PostgreSQL only.
--   
--   <i>Since: 2.2.4</i>
distinctOn :: [SqlExpr DistinctOn] -> SqlQuery a -> SqlQuery a

-- | Erase an SqlExpression's type so that it's suitable to be used by
--   <a>distinctOn</a>.
--   
--   <i>Since: 2.2.4</i>
don :: SqlExpr (Value a) -> SqlExpr DistinctOn

-- | A convenience function that calls both <a>distinctOn</a> and
--   <a>orderBy</a>. In other words,
--   
--   <pre>
--   <a>distinctOnOrderBy</a> [asc foo, desc bar, desc quux] $ do
--     ...
--   </pre>
--   
--   is the same as:
--   
--   <pre>
--   <a>distinctOn</a> [don foo, don  bar, don  quux] $ do
--     <a>orderBy</a>  [asc foo, desc bar, desc quux]
--     ...
--   </pre>
--   
--   <i>Since: 2.2.4</i>
distinctOnOrderBy :: [SqlExpr OrderBy] -> SqlQuery a -> SqlQuery a

-- | <tt>HAVING</tt>.
--   
--   <i>Since: 1.2.2</i>
having :: SqlExpr (Value Bool) -> SqlQuery ()

-- | Add a locking clause to the query. Please read <a>LockingKind</a>
--   documentation and your RDBMS manual.
--   
--   If multiple calls to <a>locking</a> are made on the same query, the
--   last one is used.
--   
--   <i>Since: 2.2.7</i>
locking :: LockingKind -> SqlQuery ()

-- | Execute a subquery <tt>SELECT</tt> in an SqlExpression. Returns a
--   simple value so should be used only when the <tt>SELECT</tt> query is
--   guaranteed to return just one row.
sub_select :: PersistField a => SqlQuery (SqlExpr (Value a)) -> SqlExpr (Value a)

-- | Project a field of an entity.
(^.) :: forall typ val. (PersistEntity val, PersistField typ) => SqlExpr (Entity val) -> EntityField val typ -> SqlExpr (Value typ)
infixl 9 ^.

-- | Project a field of an entity that may be null.
(?.) :: (PersistEntity val, PersistField typ) => SqlExpr (Maybe (Entity val)) -> EntityField val typ -> SqlExpr (Value (Maybe typ))

-- | Lift a constant value from Haskell-land to the query.
val :: PersistField typ => typ -> SqlExpr (Value typ)

-- | <tt>IS NULL</tt> comparison.
isNothing :: PersistField typ => SqlExpr (Value (Maybe typ)) -> SqlExpr (Value Bool)

-- | Analogous to <a>Just</a>, promotes a value of type <tt>typ</tt> into
--   one of type <tt>Maybe typ</tt>. It should hold that <tt><a>val</a> .
--   Just === just . <a>val</a></tt>.
just :: SqlExpr (Value typ) -> SqlExpr (Value (Maybe typ))

-- | <tt>NULL</tt> value.
nothing :: SqlExpr (Value (Maybe typ))

-- | Join nested <a>Maybe</a>s in a <a>Value</a> into one. This is useful
--   when calling aggregate functions on nullable fields.
joinV :: SqlExpr (Value (Maybe (Maybe typ))) -> SqlExpr (Value (Maybe typ))

-- | Project an SqlExpression that may be null, guarding against null
--   cases.
withNonNull :: PersistField typ => SqlExpr (Value (Maybe typ)) -> (SqlExpr (Value typ) -> SqlQuery a) -> SqlQuery a

-- | <tt>COUNT(*)</tt> value.
countRows :: Num a => SqlExpr (Value a)

-- | <tt>COUNT</tt>.
count :: Num a => SqlExpr (Value typ) -> SqlExpr (Value a)

-- | <tt>COUNT(DISTINCT x)</tt>.
--   
--   <i>Since: 2.4.1</i>
countDistinct :: Num a => SqlExpr (Value typ) -> SqlExpr (Value a)
not_ :: SqlExpr (Value Bool) -> SqlExpr (Value Bool)
(==.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 ==.
(>=.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 >=.
(>.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 >.
(<=.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 <=.
(<.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 <.
(!=.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 !=.
(&&.) :: SqlExpr (Value Bool) -> SqlExpr (Value Bool) -> SqlExpr (Value Bool)
infixr 3 &&.
(||.) :: SqlExpr (Value Bool) -> SqlExpr (Value Bool) -> SqlExpr (Value Bool)
infixr 2 ||.
(+.) :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value a) -> SqlExpr (Value a)
infixl 6 +.
(-.) :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value a) -> SqlExpr (Value a)
infixl 6 -.
(/.) :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value a) -> SqlExpr (Value a)
infixl 7 /.
(*.) :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value a) -> SqlExpr (Value a)
infixl 7 *.

-- | <i>Deprecated: Since 2.6.0: <a>random_</a> is not uniform across all
--   databases! Please use a specific one such as <a>random_</a>,
--   <a>random_</a>, or <a>random_</a></i>
random_ :: (PersistField a, Num a) => SqlExpr (Value a)
round_ :: (PersistField a, Num a, PersistField b, Num b) => SqlExpr (Value a) -> SqlExpr (Value b)
ceiling_ :: (PersistField a, Num a, PersistField b, Num b) => SqlExpr (Value a) -> SqlExpr (Value b)
floor_ :: (PersistField a, Num a, PersistField b, Num b) => SqlExpr (Value a) -> SqlExpr (Value b)
min_ :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value (Maybe a))
max_ :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value (Maybe a))
sum_ :: (PersistField a, PersistField b) => SqlExpr (Value a) -> SqlExpr (Value (Maybe b))
avg_ :: (PersistField a, PersistField b) => SqlExpr (Value a) -> SqlExpr (Value (Maybe b))

-- | Allow a number of one type to be used as one of another type via an
--   implicit cast. An explicit cast is not made, this function changes
--   only the types on the Haskell side.
--   
--   <i>Caveat</i>: Trying to use <tt>castNum</tt> from <tt>Double</tt> to
--   <tt>Int</tt> will not result in an integer, the original fractional
--   number will still be used! Use <a>round_</a>, <a>ceiling_</a> or
--   <a>floor_</a> instead.
--   
--   <i>Safety</i>: This operation is mostly safe due to the <a>Num</a>
--   constraint between the types and the fact that RDBMSs usually allow
--   numbers of different types to be used interchangeably. However, there
--   may still be issues with the query not being accepted by the RDBMS or
--   <tt>persistent</tt> not being able to parse it.
--   
--   <i>Since: 2.2.9</i>
castNum :: (Num a, Num b) => SqlExpr (Value a) -> SqlExpr (Value b)

-- | Same as <a>castNum</a>, but for nullable values.
--   
--   <i>Since: 2.2.9</i>
castNumM :: (Num a, Num b) => SqlExpr (Value (Maybe a)) -> SqlExpr (Value (Maybe b))

-- | <tt>COALESCE</tt> function. Evaluates the arguments in order and
--   returns the value of the first non-NULL SqlExpression, or NULL
--   (Nothing) otherwise. Some RDBMSs (such as SQLite) require at least two
--   arguments; please refer to the appropriate documentation.
--   
--   <i>Since: 1.4.3</i>
coalesce :: PersistField a => [SqlExpr (Value (Maybe a))] -> SqlExpr (Value (Maybe a))

-- | Like <tt>coalesce</tt>, but takes a non-nullable SqlExpression placed
--   at the end of the SqlExpression list, which guarantees a non-NULL
--   result.
--   
--   <i>Since: 1.4.3</i>
coalesceDefault :: PersistField a => [SqlExpr (Value (Maybe a))] -> SqlExpr (Value a) -> SqlExpr (Value a)

-- | <tt>LOWER</tt> function.
lower_ :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s)

-- | <tt>LIKE</tt> operator.
like :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s) -> SqlExpr (Value Bool)
infixr 2 `like`

-- | <tt>ILIKE</tt> operator (case-insensitive <tt>LIKE</tt>).
--   
--   Supported by PostgreSQL only.
--   
--   <i>Since: 2.2.3</i>
ilike :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s) -> SqlExpr (Value Bool)
infixr 2 `ilike`

-- | The string <tt><a>%</a></tt>. May be useful while using <a>like</a>
--   and concatenation (<a>concat_</a> or <a>++.</a>, depending on your
--   database). Note that you always have to type the parenthesis, for
--   example:
--   
--   <pre>
--   name `<a>like</a>` (%) ++. <a>val</a> "John" ++. (%)
--   </pre>
(%) :: SqlString s => SqlExpr (Value s)

-- | The <tt>CONCAT</tt> function with a variable number of parameters.
--   Supported by MySQL and PostgreSQL.
concat_ :: SqlString s => [SqlExpr (Value s)] -> SqlExpr (Value s)

-- | The <tt>||</tt> string concatenation operator (named after Haskell's
--   <a>++</a> in order to avoid naming clash with <a>||.</a>). Supported
--   by SQLite and PostgreSQL.
(++.) :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s) -> SqlExpr (Value s)
infixr 5 ++.

-- | Cast a string type into <tt>Text</tt>. This function is very useful if
--   you want to use <tt>newtype</tt>s, or if you want to apply functions
--   such as <a>like</a> to strings of different types.
--   
--   <i>Safety:</i> This is a slightly unsafe function, especially if you
--   have defined your own instances of <a>SqlString</a>. Also, since
--   <a>Maybe</a> is an instance of <a>SqlString</a>, it's possible to turn
--   a nullable value into a non-nullable one. Avoid using this function if
--   possible.
castString :: (SqlString s, SqlString r) => SqlExpr (Value s) -> SqlExpr (Value r)

-- | Execute a subquery <tt>SELECT</tt> in an SqlExpression. Returns a list
--   of values.
subList_select :: PersistField a => SqlQuery (SqlExpr (Value a)) -> SqlExpr (ValueList a)

-- | Lift a list of constant value from Haskell-land to the query.
valList :: PersistField typ => [typ] -> SqlExpr (ValueList typ)

-- | Same as <a>just</a> but for <a>ValueList</a>. Most of the time you
--   won't need it, though, because you can use <a>just</a> from inside
--   <a>subList_select</a> or <a>Just</a> from inside <a>valList</a>.
--   
--   <i>Since: 2.2.12</i>
justList :: SqlExpr (ValueList typ) -> SqlExpr (ValueList (Maybe typ))

-- | <tt>IN</tt> operator. For example if you want to select all
--   <tt>Person</tt>s by a list of IDs:
--   
--   <pre>
--   SELECT *
--   FROM Person
--   WHERE Person.id IN (?)
--   </pre>
--   
--   In <tt>esqueleto</tt>, we may write the same query above as:
--   
--   <pre>
--   select $
--   <a>from</a> $ \person -&gt; do
--   <a>where_</a> $ person <a>^.</a> PersonId `<a>in_</a>` <a>valList</a> personIds
--   return person
--   </pre>
--   
--   Where <tt>personIds</tt> is of type <tt>[Key Person]</tt>.
in_ :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (ValueList typ) -> SqlExpr (Value Bool)

-- | <tt>NOT IN</tt> operator.
notIn :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (ValueList typ) -> SqlExpr (Value Bool)

-- | <tt>EXISTS</tt> operator. For example:
--   
--   <pre>
--   select $
--   <a>from</a> $ \person -&gt; do
--   <a>where_</a> $ <a>exists</a> $
--            <a>from</a> $ \post -&gt; do
--            <a>where_</a> (post <a>^.</a> BlogPostAuthorId <a>==.</a> person <a>^.</a> PersonId)
--   return person
--   </pre>
exists :: SqlQuery () -> SqlExpr (Value Bool)

-- | <tt>NOT EXISTS</tt> operator.
notExists :: SqlQuery () -> SqlExpr (Value Bool)

-- | <tt>SET</tt> clause used on <tt>UPDATE</tt>s. Note that while it's not
--   a type error to use this function on a <tt>SELECT</tt>, it will most
--   certainly result in a runtime error.
set :: PersistEntity val => SqlExpr (Entity val) -> [SqlExpr (Update val)] -> SqlQuery ()
(=.) :: (PersistEntity val, PersistField typ) => EntityField val typ -> SqlExpr (Value typ) -> SqlExpr (Update val)
infixr 3 =.
(+=.) :: (PersistEntity val, PersistField a) => EntityField val a -> SqlExpr (Value a) -> SqlExpr (Update val)
infixr 3 +=.
(-=.) :: (PersistEntity val, PersistField a) => EntityField val a -> SqlExpr (Value a) -> SqlExpr (Update val)
infixr 3 -=.
(*=.) :: (PersistEntity val, PersistField a) => EntityField val a -> SqlExpr (Value a) -> SqlExpr (Update val)
infixr 3 *=.
(/=.) :: (PersistEntity val, PersistField a) => EntityField val a -> SqlExpr (Value a) -> SqlExpr (Update val)
infixr 3 /=.

-- | <tt>CASE</tt> statement. For example:
--   
--   <pre>
--   select $
--   return $
--   <a>case_</a>
--      [ <a>when_</a>
--          (<a>exists</a> $
--          <a>from</a> $ \p -&gt; do
--          <a>where_</a> (p <a>^.</a> PersonName <a>==.</a> <a>val</a> "Mike"))
--        <a>then_</a>
--          (<a>sub_select</a> $
--          <a>from</a> $ \v -&gt; do
--          let sub =
--                  <a>from</a> $ \c -&gt; do
--                  <a>where_</a> (c <a>^.</a> PersonName <a>==.</a> <a>val</a> "Mike")
--                  return (c <a>^.</a> PersonFavNum)
--          <a>where_</a> (v <a>^.</a> PersonFavNum &gt;. <a>sub_select</a> sub)
--          return $ <a>count</a> (v <a>^.</a> PersonName) +. <a>val</a> (1 :: Int)) ]
--      (<a>else_</a> $ <a>val</a> (-1))
--   </pre>
--   
--   This query is a bit complicated, but basically it checks if a person
--   named <tt>"Mike"</tt> exists, and if that person does, run the
--   subquery to find out how many people have a ranking (by Fav Num)
--   higher than <tt>"Mike"</tt>.
--   
--   <b>NOTE:</b> There are a few things to be aware about this statement.
--   
--   <ul>
--   <li>This only implements the full CASE statement, it does not
--   implement the "simple" CASE statement.</li>
--   <li>At least one <a>when_</a> and <a>then_</a> is mandatory otherwise
--   it will emit an error.</li>
--   <li>The <a>else_</a> is also mandatory, unlike the SQL statement in
--   which if the <tt>ELSE</tt> is omitted it will return a <tt>NULL</tt>.
--   You can reproduce this via <a>nothing</a>.</li>
--   </ul>
--   
--   <i>Since: 2.1.2</i>
case_ :: PersistField a => [(SqlExpr (Value Bool), SqlExpr (Value a))] -> SqlExpr (Value a) -> SqlExpr (Value a)

-- | Convert an entity's key into another entity's.
--   
--   This function is to be used when you change an entity's <tt>Id</tt> to
--   be that of another entity. For example:
--   
--   <pre>
--   Bar
--     barNum Int
--   Foo
--     Id BarId
--     fooNum Int
--   </pre>
--   
--   For this example, declare:
--   
--   <pre>
--   instance ToBaseId Foo where
--     type BaseEnt Foo = Bar
--     toBaseIdWitness = FooKey
--   </pre>
--   
--   Now you're able to write queries such as:
--   
--   <pre>
--   <a>select</a> $
--   <a>from</a> $ (bar `<a>InnerJoin</a>` foo) -&gt; do
--   <a>on</a> (<a>toBaseId</a> (foo <a>^.</a> FooId) <a>==.</a> bar <a>^.</a> BarId)
--   return (bar, foo)
--   </pre>
--   
--   Note: this function may be unsafe to use in conditions not like the
--   one of the example above.
--   
--   <i>Since: 2.4.3</i>
toBaseId :: ToBaseId ent => SqlExpr (Value (Key ent)) -> SqlExpr (Value (Key (BaseEnt ent)))

-- | Apply a <a>PersistField</a> constructor to <tt>SqlExpr Value</tt>
--   arguments.
(<#) :: (a -> b) -> SqlExpr (Value a) -> SqlExpr (Insertion b)

-- | Apply extra <tt>SqlExpr Value</tt> arguments to a <a>PersistField</a>
--   constructor
(<&>) :: SqlExpr (Insertion (a -> b)) -> SqlExpr (Value a) -> SqlExpr (Insertion b)


-- | This is an internal module, anything exported by this module may
--   change without a major version bump. Please use only
--   <a>Database.Esqueleto</a> if possible.
module Database.Esqueleto.Internal.Sql

-- | SQL backend for <tt>esqueleto</tt> using <a>SqlPersistT</a>.
data SqlQuery a

-- | An expression on the SQL backend.
--   
--   There are many comments describing the constructors of this data type.
--   However, Haddock doesn't like GADTs, so you'll have to read them by
--   hitting "Source".
data SqlExpr a
[EEntity] :: Ident -> SqlExpr (Entity val)
[EMaybe] :: SqlExpr a -> SqlExpr (Maybe a)
[ERaw] :: NeedParens -> (IdentInfo -> (Builder, [PersistValue])) -> SqlExpr (Value a)
[ECompositeKey] :: (IdentInfo -> [Builder]) -> SqlExpr (Value a)
[EList] :: SqlExpr (Value a) -> SqlExpr (ValueList a)
[EEmptyList] :: SqlExpr (ValueList a)
[EOrderBy] :: OrderByType -> SqlExpr (Value a) -> SqlExpr OrderBy

-- | <i>Deprecated: Since 2.6.0: <a>rand</a> ordering function is not
--   uniform across all databases! To avoid accidental partiality it will
--   be removed in the next major version.</i>
[EOrderRandom] :: SqlExpr OrderBy
[EDistinctOn] :: SqlExpr (Value a) -> SqlExpr DistinctOn
[ESet] :: (SqlExpr (Entity val) -> SqlExpr (Value ())) -> SqlExpr (Update val)
[EPreprocessedFrom] :: a -> FromClause -> SqlExpr (PreprocessedFrom a)
[EInsert] :: Proxy a -> (IdentInfo -> (Builder, [PersistValue])) -> SqlExpr (Insertion a)
[EInsertFinal] :: PersistEntity a => SqlExpr (Insertion a) -> SqlExpr InsertFinal

-- | Constraint synonym for <tt>persistent</tt> entities whose backend is
--   <a>SqlPersistT</a>.
type SqlEntity ent = (PersistEntity ent, PersistEntityBackend ent ~ SqlBackend)

-- | Execute an <tt>esqueleto</tt> <tt>SELECT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a list of
--   rows.
--   
--   We've seen that <a>from</a> has some magic about which kinds of things
--   you may bring into scope. This <a>select</a> function also has some
--   magic for which kinds of things you may bring back to Haskell-land by
--   using <tt>SqlQuery</tt>'s <tt>return</tt>:
--   
--   <ul>
--   <li>You may return a <tt>SqlExpr (<a>Entity</a> v)</tt> for an entity
--   <tt>v</tt> (i.e., like the <tt>*</tt> in SQL), which is then returned
--   to Haskell-land as just <tt>Entity v</tt>.</li>
--   <li>You may return a <tt>SqlExpr (Maybe (Entity v))</tt> for an entity
--   <tt>v</tt> that may be <tt>NULL</tt>, which is then returned to
--   Haskell-land as <tt>Maybe (Entity v)</tt>. Used for <tt>OUTER
--   JOIN</tt>s.</li>
--   <li>You may return a <tt>SqlExpr (<a>Value</a> t)</tt> for a value
--   <tt>t</tt> (i.e., a single column), where <tt>t</tt> is any instance
--   of <a>PersistField</a>, which is then returned to Haskell-land as
--   <tt>Value t</tt>. You may use <tt>Value</tt> to return projections of
--   an <tt>Entity</tt> (see <tt>(<a>^.</a>)</tt> and <tt>(<a>?.</a>)</tt>)
--   or to return any other value calculated on the query (e.g.,
--   <a>countRows</a> or <a>sub_select</a>).</li>
--   </ul>
--   
--   The <tt>SqlSelect a r</tt> class has functional dependencies that
--   allow type information to flow both from <tt>a</tt> to <tt>r</tt> and
--   vice-versa. This means that you'll almost never have to give any type
--   signatures for <tt>esqueleto</tt> queries. For example, the query
--   <tt><a>select</a> $ from $ \p -&gt; return p</tt> alone is ambiguous,
--   but in the context of
--   
--   <pre>
--   do ps &lt;- <a>select</a> $
--            <a>from</a> $ \p -&gt;
--            return p
--      liftIO $ mapM_ (putStrLn . personName . entityVal) ps
--   </pre>
--   
--   we are able to infer from that single <tt>personName . entityVal</tt>
--   function composition that the <tt>p</tt> inside the query is of type
--   <tt>SqlExpr (Entity Person)</tt>.
select :: (SqlSelect a r, MonadIO m) => SqlQuery a -> SqlReadT m [r]

-- | Execute an <tt>esqueleto</tt> <tt>SELECT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a
--   <a>Source</a> of rows.
selectSource :: (SqlSelect a r, BackendCompatible SqlBackend backend, IsPersistBackend backend, PersistQueryRead backend, PersistStoreRead backend, PersistUniqueRead backend, MonadResource m) => SqlQuery a -> ConduitT () r (ReaderT backend m) ()

-- | Execute an <tt>esqueleto</tt> <tt>DELETE</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad. Note that currently
--   there are no type checks for statements that should not appear on a
--   <tt>DELETE</tt> query.
--   
--   Example of usage:
--   
--   <pre>
--   <a>delete</a> $
--   <a>from</a> $ \appointment -&gt;
--   <a>where_</a> (appointment <a>^.</a> AppointmentDate <a>&lt;.</a> <a>val</a> now)
--   </pre>
--   
--   Unlike <a>select</a>, there is a useful way of using <a>delete</a>
--   that will lead to type ambiguities. If you want to delete all rows
--   (i.e., no <a>where_</a> clause), you'll have to use a type signature:
--   
--   <pre>
--   <a>delete</a> $
--   <a>from</a> $ \(appointment :: <a>SqlExpr</a> (<a>Entity</a> Appointment)) -&gt;
--   return ()
--   </pre>
delete :: MonadIO m => SqlQuery () -> SqlWriteT m ()

-- | Same as <a>delete</a>, but returns the number of rows affected.
deleteCount :: MonadIO m => SqlQuery () -> SqlWriteT m Int64

-- | Execute an <tt>esqueleto</tt> <tt>UPDATE</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad. Note that currently
--   there are no type checks for statements that should not appear on a
--   <tt>UPDATE</tt> query.
--   
--   Example of usage:
--   
--   <pre>
--   <a>update</a> $ \p -&gt; do
--   <a>set</a> p [ PersonAge <a>=.</a> <a>just</a> (<a>val</a> thisYear) -. p <a>^.</a> PersonBorn ]
--   <a>where_</a> $ isNothing (p <a>^.</a> PersonAge)
--   </pre>
update :: (MonadIO m, PersistEntity val, BackendCompatible SqlBackend (PersistEntityBackend val)) => (SqlExpr (Entity val) -> SqlQuery ()) -> SqlWriteT m ()

-- | Same as <a>update</a>, but returns the number of rows affected.
updateCount :: (MonadIO m, PersistEntity val, BackendCompatible SqlBackend (PersistEntityBackend val)) => (SqlExpr (Entity val) -> SqlQuery ()) -> SqlWriteT m Int64

-- | Insert a <a>PersistField</a> for every selected value.
--   
--   <i>Since: 2.4.2</i>
insertSelect :: (MonadIO m, PersistEntity a) => SqlQuery (SqlExpr (Insertion a)) -> SqlWriteT m ()

-- | Insert a <a>PersistField</a> for every selected value, return the
--   count afterward
insertSelectCount :: (MonadIO m, PersistEntity a) => SqlQuery (SqlExpr (Insertion a)) -> SqlWriteT m Int64

-- | (Internal) Create a case statement.
--   
--   Since: 2.1.1
unsafeSqlCase :: PersistField a => [(SqlExpr (Value Bool), SqlExpr (Value a))] -> SqlExpr (Value a) -> SqlExpr (Value a)

-- | (Internal) Create a custom binary operator. You <i>should</i>
--   <i>not</i> use this function directly since its type is very general,
--   you should always use it with an explicit type signature. For example:
--   
--   <pre>
--   (==.) :: SqlExpr (Value a) -&gt; SqlExpr (Value a) -&gt; SqlExpr (Value Bool)
--   (==.) = unsafeSqlBinOp " = "
--   </pre>
--   
--   In the example above, we constraint the arguments to be of the same
--   type and constraint the result to be a boolean value.
unsafeSqlBinOp :: Builder -> SqlExpr (Value a) -> SqlExpr (Value b) -> SqlExpr (Value c)

-- | Similar to <a>unsafeSqlBinOp</a>, but may also be applied to composite
--   keys. Uses the operator given as the second argument whenever applied
--   to composite keys.
--   
--   Usage example:
--   
--   <pre>
--   (==.) :: SqlExpr (Value a) -&gt; SqlExpr (Value a) -&gt; SqlExpr (Value Bool)
--   (==.) = unsafeSqlBinOpComposite " = " " AND "
--   </pre>
--   
--   Persistent has a hack for implementing composite keys (see
--   <a>ECompositeKey</a> doc for more details), so we're forced to use a
--   hack here as well. We deconstruct <a>ERaw</a> values based on two
--   rules:
--   
--   <ul>
--   <li>If it is a single placeholder, then it's assumed to be coming from
--   a <a>PersistList</a> and thus its components are separated so that
--   they may be applied to a composite key.</li>
--   <li>If it is not a single placeholder, then it's assumed to be a
--   foreign (composite or not) key, so we enforce that it has no
--   placeholders and split it on the commas.</li>
--   </ul>
unsafeSqlBinOpComposite :: Builder -> Builder -> SqlExpr (Value a) -> SqlExpr (Value b) -> SqlExpr (Value c)

-- | (Internal) A raw SQL value. The same warning from
--   <a>unsafeSqlBinOp</a> applies to this function as well.
unsafeSqlValue :: Builder -> SqlExpr (Value a)

-- | (Internal) An explicit SQL type cast using CAST(value as type). See
--   <a>unsafeSqlBinOp</a> for warnings.
unsafeSqlCastAs :: Text -> SqlExpr (Value a) -> SqlExpr (Value b)

-- | (Internal) A raw SQL function. Once again, the same warning from
--   <a>unsafeSqlBinOp</a> applies to this function as well.
unsafeSqlFunction :: UnsafeSqlFunctionArgument a => Builder -> a -> SqlExpr (Value b)

-- | (Internal) An unsafe SQL function to extract a subfield from a
--   compound field, e.g. datetime. See <a>unsafeSqlBinOp</a> for warnings.
--   
--   Since: 1.3.6.
unsafeSqlExtractSubField :: UnsafeSqlFunctionArgument a => Builder -> a -> SqlExpr (Value b)
class UnsafeSqlFunctionArgument a

-- | A <tt>ORDER BY</tt> clause.
type OrderByClause = SqlExpr OrderBy

-- | (Internal) Execute an <tt>esqueleto</tt> <tt>SELECT</tt>
--   <a>SqlQuery</a> inside <tt>persistent</tt>'s <a>SqlPersistT</a> monad.
rawSelectSource :: (SqlSelect a r, MonadIO m1, MonadIO m2) => Mode -> SqlQuery a -> SqlReadT m1 (Acquire (ConduitT () r m2 ()))

-- | (Internal) Run a <a>Source</a> of rows.
runSource :: Monad m => ConduitT () r (ReaderT backend m) () -> ReaderT backend m [r]

-- | (Internal) Execute an <tt>esqueleto</tt> statement inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad.
rawEsqueleto :: (MonadIO m, SqlSelect a r, BackendCompatible SqlBackend backend) => Mode -> SqlQuery a -> ReaderT backend m Int64

-- | (Internal) Pretty prints a <a>SqlQuery</a> into a SQL query.
--   
--   Note: if you're curious about the SQL query being generated by
--   <tt>esqueleto</tt>, instead of manually using this function (which is
--   possible but tedious), you may just turn on query logging of
--   <tt>persistent</tt>.
toRawSql :: (SqlSelect a r, BackendCompatible SqlBackend backend) => Mode -> (backend, IdentState) -> SqlQuery a -> (Builder, [PersistValue])

-- | (Internal) Mode of query being converted by <a>toRawSql</a>.
data Mode
SELECT :: Mode
DELETE :: Mode
UPDATE :: Mode
INSERT_INTO :: Mode
data NeedParens
Parens :: NeedParens
Never :: NeedParens

-- | List of identifiers already in use and supply of temporary
--   identifiers.
data IdentState
initialIdentState :: IdentState

-- | Information needed to escape and use identifiers.
type IdentInfo = (SqlBackend, IdentState)

-- | (Internal) Class for mapping results coming from <a>SqlQuery</a> into
--   actual results.
--   
--   This looks very similar to <tt>RawSql</tt>, and it is! However, there
--   are some crucial differences and ultimately they're different classes.
class SqlSelect a r | a -> r, r -> a

-- | Creates the variable part of the <tt>SELECT</tt> query and returns the
--   list of <a>PersistValue</a>s that will be given to <a>rawQuery</a>.
sqlSelectCols :: SqlSelect a r => IdentInfo -> a -> (Builder, [PersistValue])

-- | Number of columns that will be consumed.
sqlSelectColCount :: SqlSelect a r => Proxy a -> Int

-- | Transform a row of the result into the data type.
sqlSelectProcessRow :: SqlSelect a r => [PersistValue] -> Either Text r

-- | Create <tt>INSERT INTO</tt> clause instead.
sqlInsertInto :: SqlSelect a r => IdentInfo -> a -> (Builder, [PersistValue])

-- | (Internal) Coerce a value's type from 'SqlExpr (Value a)' to 'SqlExpr
--   (Value b)'. You should <i>not</i> use this function unless you know
--   what you're doing!
veryUnsafeCoerceSqlExprValue :: SqlExpr (Value a) -> SqlExpr (Value b)

-- | (Internal) Coerce a value's type from 'SqlExpr (ValueList a)' to
--   'SqlExpr (Value a)'. Does not work with empty lists.
veryUnsafeCoerceSqlExprValueList :: SqlExpr (ValueList a) -> SqlExpr (Value a)
makeOrderByNoNewline :: IdentInfo -> [OrderByClause] -> (Builder, [PersistValue])
uncommas' :: Monoid a => [(Builder, a)] -> (Builder, a)
parens :: Builder -> Builder
toArgList :: UnsafeSqlFunctionArgument a => a -> [SqlExpr (Value ())]
builderToText :: Builder -> Text


-- | The <tt>esqueleto</tt> EDSL (embedded domain specific language). This
--   module replaces <tt>Database.Persist</tt>, so instead of importing
--   that module you should just import this one:
--   
--   <pre>
--   -- For a module using just esqueleto.
--   import Database.Esqueleto
--   </pre>
--   
--   If you need to use <tt>persistent</tt>'s default support for queries
--   as well, either import it qualified:
--   
--   <pre>
--   -- For a module that mostly uses esqueleto.
--   import Database.Esqueleto
--   import qualified Database.Persist as P
--   </pre>
--   
--   or import <tt>esqueleto</tt> itself qualified:
--   
--   <pre>
--   -- For a module that uses esqueleto just on some queries.
--   import Database.Persist
--   import qualified Database.Esqueleto as E
--   </pre>
--   
--   Other than identifier name clashes, <tt>esqueleto</tt> does not
--   conflict with <tt>persistent</tt> in any way.
module Database.Esqueleto

-- | <tt>WHERE</tt> clause: restrict the query's result.
where_ :: SqlExpr (Value Bool) -> SqlQuery ()

-- | <tt>ON</tt> clause: restrict the a <tt>JOIN</tt>'s result. The
--   <tt>ON</tt> clause will be applied to the <i>last</i> <tt>JOIN</tt>
--   that does not have an <tt>ON</tt> clause yet. If there are no
--   <tt>JOIN</tt>s without <tt>ON</tt> clauses (either because you didn't
--   do any <tt>JOIN</tt>, or because all <tt>JOIN</tt>s already have their
--   own <tt>ON</tt> clauses), a runtime exception
--   <a>OnClauseWithoutMatchingJoinException</a> is thrown. <tt>ON</tt>
--   clauses are optional when doing <tt>JOIN</tt>s.
--   
--   On the simple case of doing just one <tt>JOIN</tt>, for example
--   
--   <pre>
--   select $
--   <a>from</a> $ \(foo `<a>InnerJoin</a>` bar) -&gt; do
--     <a>on</a> (foo <a>^.</a> FooId <a>==.</a> bar <a>^.</a> BarFooId)
--     ...
--   </pre>
--   
--   there's no ambiguity and the rules above just mean that you're allowed
--   to call <a>on</a> only once (as in SQL). If you have many joins, then
--   the <a>on</a>s are applied on the <i>reverse</i> order that the
--   <tt>JOIN</tt>s appear. For example:
--   
--   <pre>
--   select $
--   <a>from</a> $ \(foo `<a>InnerJoin</a>` bar `<a>InnerJoin</a>` baz) -&gt; do
--     <a>on</a> (baz <a>^.</a> BazId <a>==.</a> bar <a>^.</a> BarBazId)
--     <a>on</a> (foo <a>^.</a> FooId <a>==.</a> bar <a>^.</a> BarFooId)
--     ...
--   </pre>
--   
--   The order is <i>reversed</i> in order to improve composability. For
--   example, consider <tt>query1</tt> and <tt>query2</tt> below:
--   
--   <pre>
--   let query1 =
--         <a>from</a> $ \(foo `<a>InnerJoin</a>` bar) -&gt; do
--           <a>on</a> (foo <a>^.</a> FooId <a>==.</a> bar <a>^.</a> BarFooId)
--       query2 =
--         <a>from</a> $ \(mbaz `<a>LeftOuterJoin</a>` quux) -&gt; do
--           return (mbaz <a>?.</a> BazName, quux)
--       test1 =      (,) &lt;$&gt; query1 &lt;*&gt; query2
--       test2 = flip (,) &lt;$&gt; query2 &lt;*&gt; query1
--   </pre>
--   
--   If the order was <i>not</i> reversed, then <tt>test2</tt> would be
--   broken: <tt>query1</tt>'s <a>on</a> would refer to <tt>query2</tt>'s
--   <a>LeftOuterJoin</a>.
on :: SqlExpr (Value Bool) -> SqlQuery ()

-- | <tt>GROUP BY</tt> clause. You can enclose multiple columns in a tuple.
--   
--   <pre>
--   select $ <a>from</a> \(foo `<a>InnerJoin</a>` bar) -&gt; do
--     <a>on</a> (foo <a>^.</a> FooBarId <a>==.</a> bar <a>^.</a> BarId)
--     <a>groupBy</a> (bar <a>^.</a> BarId, bar <a>^.</a> BarName)
--     return (bar <a>^.</a> BarId, bar <a>^.</a> BarName, countRows)
--   </pre>
--   
--   With groupBy you can sort by aggregate functions, like so (we used
--   <tt>let</tt> to restrict the more general <a>countRows</a> to
--   <tt>SqlSqlExpr (Value Int)</tt> to avoid ambiguity---the second use of
--   <a>countRows</a> has its type restricted by the <tt>:: Int</tt>
--   below):
--   
--   <pre>
--   r &lt;- select $ <a>from</a> \(foo `<a>InnerJoin</a>` bar) -&gt; do
--     <a>on</a> (foo <a>^.</a> FooBarId <a>==.</a> bar <a>^.</a> BarId)
--     <a>groupBy</a> $ bar <a>^.</a> BarName
--     let countRows' = <a>countRows</a>
--     <a>orderBy</a> [<a>asc</a> countRows']
--     return (bar <a>^.</a> BarName, countRows')
--   forM_ r $ \(<a>Value</a> name, <a>Value</a> count) -&gt; do
--     print name
--     print (count :: Int)
--   </pre>
groupBy :: ToSomeValues a => a -> SqlQuery ()

-- | <tt>ORDER BY</tt> clause. See also <a>asc</a> and <a>desc</a>.
--   
--   Multiple calls to <a>orderBy</a> get concatenated on the final query,
--   including <a>distinctOnOrderBy</a>.
orderBy :: [SqlExpr OrderBy] -> SqlQuery ()

-- | <tt>ORDER BY random()</tt> clause.
--   
--   <i>Since: 1.3.10</i>

-- | <i>Deprecated: Since 2.6.0: <a>rand</a> ordering function is not
--   uniform across all databases! To avoid accidental partiality it will
--   be removed in the next major version.</i>
rand :: SqlExpr OrderBy

-- | Ascending order of this field or SqlExpression.
asc :: PersistField a => SqlExpr (Value a) -> SqlExpr OrderBy

-- | Descending order of this field or SqlExpression.
desc :: PersistField a => SqlExpr (Value a) -> SqlExpr OrderBy

-- | <tt>LIMIT</tt>. Limit the number of returned rows.
limit :: Int64 -> SqlQuery ()

-- | <tt>OFFSET</tt>. Usually used with <a>limit</a>.
offset :: Int64 -> SqlQuery ()

-- | <tt>DISTINCT</tt>. Change the current <tt>SELECT</tt> into <tt>SELECT
--   DISTINCT</tt>. For example:
--   
--   <pre>
--   select $ distinct $
--     <a>from</a> \foo -&gt; do
--     ...
--   </pre>
--   
--   Note that this also has the same effect:
--   
--   <pre>
--   select $
--     <a>from</a> \foo -&gt; do
--     distinct (return ())
--     ...
--   </pre>
--   
--   <i>Since: 2.2.4</i>
distinct :: SqlQuery a -> SqlQuery a

-- | <tt>DISTINCT ON</tt>. Change the current <tt>SELECT</tt> into
--   <tt>SELECT DISTINCT ON (SqlExpressions)</tt>. For example:
--   
--   <pre>
--   select $
--     <a>from</a> \foo -&gt;
--     <a>distinctOn</a> [<a>don</a> (foo ^. FooName), <a>don</a> (foo ^. FooState)] $ do
--     ...
--   </pre>
--   
--   You can also chain different calls to <a>distinctOn</a>. The above is
--   equivalent to:
--   
--   <pre>
--   select $
--     <a>from</a> \foo -&gt;
--     <a>distinctOn</a> [<a>don</a> (foo ^. FooName)] $
--     <a>distinctOn</a> [<a>don</a> (foo ^. FooState)] $ do
--     ...
--   </pre>
--   
--   Each call to <a>distinctOn</a> adds more SqlExpressions. Calls to
--   <a>distinctOn</a> override any calls to <a>distinct</a>.
--   
--   Note that PostgreSQL requires the SqlExpressions on <tt>DISTINCT
--   ON</tt> to be the first ones to appear on a <tt>ORDER BY</tt>. This is
--   not managed automatically by esqueleto, keeping its spirit of trying
--   to be close to raw SQL.
--   
--   Supported by PostgreSQL only.
--   
--   <i>Since: 2.2.4</i>
distinctOn :: [SqlExpr DistinctOn] -> SqlQuery a -> SqlQuery a

-- | Erase an SqlExpression's type so that it's suitable to be used by
--   <a>distinctOn</a>.
--   
--   <i>Since: 2.2.4</i>
don :: SqlExpr (Value a) -> SqlExpr DistinctOn

-- | A convenience function that calls both <a>distinctOn</a> and
--   <a>orderBy</a>. In other words,
--   
--   <pre>
--   <a>distinctOnOrderBy</a> [asc foo, desc bar, desc quux] $ do
--     ...
--   </pre>
--   
--   is the same as:
--   
--   <pre>
--   <a>distinctOn</a> [don foo, don  bar, don  quux] $ do
--     <a>orderBy</a>  [asc foo, desc bar, desc quux]
--     ...
--   </pre>
--   
--   <i>Since: 2.2.4</i>
distinctOnOrderBy :: [SqlExpr OrderBy] -> SqlQuery a -> SqlQuery a

-- | <tt>HAVING</tt>.
--   
--   <i>Since: 1.2.2</i>
having :: SqlExpr (Value Bool) -> SqlQuery ()

-- | Add a locking clause to the query. Please read <a>LockingKind</a>
--   documentation and your RDBMS manual.
--   
--   If multiple calls to <a>locking</a> are made on the same query, the
--   last one is used.
--   
--   <i>Since: 2.2.7</i>
locking :: LockingKind -> SqlQuery ()

-- | Execute a subquery <tt>SELECT</tt> in an SqlExpression. Returns a
--   simple value so should be used only when the <tt>SELECT</tt> query is
--   guaranteed to return just one row.
sub_select :: PersistField a => SqlQuery (SqlExpr (Value a)) -> SqlExpr (Value a)

-- | Project a field of an entity.
(^.) :: forall typ val. (PersistEntity val, PersistField typ) => SqlExpr (Entity val) -> EntityField val typ -> SqlExpr (Value typ)
infixl 9 ^.

-- | Project a field of an entity that may be null.
(?.) :: (PersistEntity val, PersistField typ) => SqlExpr (Maybe (Entity val)) -> EntityField val typ -> SqlExpr (Value (Maybe typ))

-- | Lift a constant value from Haskell-land to the query.
val :: PersistField typ => typ -> SqlExpr (Value typ)

-- | <tt>IS NULL</tt> comparison.
isNothing :: PersistField typ => SqlExpr (Value (Maybe typ)) -> SqlExpr (Value Bool)

-- | Analogous to <a>Just</a>, promotes a value of type <tt>typ</tt> into
--   one of type <tt>Maybe typ</tt>. It should hold that <tt><a>val</a> .
--   Just === just . <a>val</a></tt>.
just :: SqlExpr (Value typ) -> SqlExpr (Value (Maybe typ))

-- | <tt>NULL</tt> value.
nothing :: SqlExpr (Value (Maybe typ))

-- | Join nested <a>Maybe</a>s in a <a>Value</a> into one. This is useful
--   when calling aggregate functions on nullable fields.
joinV :: SqlExpr (Value (Maybe (Maybe typ))) -> SqlExpr (Value (Maybe typ))

-- | Project an SqlExpression that may be null, guarding against null
--   cases.
withNonNull :: PersistField typ => SqlExpr (Value (Maybe typ)) -> (SqlExpr (Value typ) -> SqlQuery a) -> SqlQuery a

-- | <tt>COUNT(*)</tt> value.
countRows :: Num a => SqlExpr (Value a)

-- | <tt>COUNT</tt>.
count :: Num a => SqlExpr (Value typ) -> SqlExpr (Value a)

-- | <tt>COUNT(DISTINCT x)</tt>.
--   
--   <i>Since: 2.4.1</i>
countDistinct :: Num a => SqlExpr (Value typ) -> SqlExpr (Value a)
not_ :: SqlExpr (Value Bool) -> SqlExpr (Value Bool)
(==.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 ==.
(>=.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 >=.
(>.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 >.
(<=.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 <=.
(<.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 <.
(!=.) :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (Value typ) -> SqlExpr (Value Bool)
infix 4 !=.
(&&.) :: SqlExpr (Value Bool) -> SqlExpr (Value Bool) -> SqlExpr (Value Bool)
infixr 3 &&.
(||.) :: SqlExpr (Value Bool) -> SqlExpr (Value Bool) -> SqlExpr (Value Bool)
infixr 2 ||.
(+.) :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value a) -> SqlExpr (Value a)
infixl 6 +.
(-.) :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value a) -> SqlExpr (Value a)
infixl 6 -.
(/.) :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value a) -> SqlExpr (Value a)
infixl 7 /.
(*.) :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value a) -> SqlExpr (Value a)
infixl 7 *.

-- | <i>Deprecated: Since 2.6.0: <a>random_</a> is not uniform across all
--   databases! Please use a specific one such as <a>random_</a>,
--   <a>random_</a>, or <a>random_</a></i>
random_ :: (PersistField a, Num a) => SqlExpr (Value a)
round_ :: (PersistField a, Num a, PersistField b, Num b) => SqlExpr (Value a) -> SqlExpr (Value b)
ceiling_ :: (PersistField a, Num a, PersistField b, Num b) => SqlExpr (Value a) -> SqlExpr (Value b)
floor_ :: (PersistField a, Num a, PersistField b, Num b) => SqlExpr (Value a) -> SqlExpr (Value b)
min_ :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value (Maybe a))
max_ :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value (Maybe a))
sum_ :: (PersistField a, PersistField b) => SqlExpr (Value a) -> SqlExpr (Value (Maybe b))
avg_ :: (PersistField a, PersistField b) => SqlExpr (Value a) -> SqlExpr (Value (Maybe b))

-- | Allow a number of one type to be used as one of another type via an
--   implicit cast. An explicit cast is not made, this function changes
--   only the types on the Haskell side.
--   
--   <i>Caveat</i>: Trying to use <tt>castNum</tt> from <tt>Double</tt> to
--   <tt>Int</tt> will not result in an integer, the original fractional
--   number will still be used! Use <a>round_</a>, <a>ceiling_</a> or
--   <a>floor_</a> instead.
--   
--   <i>Safety</i>: This operation is mostly safe due to the <a>Num</a>
--   constraint between the types and the fact that RDBMSs usually allow
--   numbers of different types to be used interchangeably. However, there
--   may still be issues with the query not being accepted by the RDBMS or
--   <tt>persistent</tt> not being able to parse it.
--   
--   <i>Since: 2.2.9</i>
castNum :: (Num a, Num b) => SqlExpr (Value a) -> SqlExpr (Value b)

-- | Same as <a>castNum</a>, but for nullable values.
--   
--   <i>Since: 2.2.9</i>
castNumM :: (Num a, Num b) => SqlExpr (Value (Maybe a)) -> SqlExpr (Value (Maybe b))

-- | <tt>COALESCE</tt> function. Evaluates the arguments in order and
--   returns the value of the first non-NULL SqlExpression, or NULL
--   (Nothing) otherwise. Some RDBMSs (such as SQLite) require at least two
--   arguments; please refer to the appropriate documentation.
--   
--   <i>Since: 1.4.3</i>
coalesce :: PersistField a => [SqlExpr (Value (Maybe a))] -> SqlExpr (Value (Maybe a))

-- | Like <tt>coalesce</tt>, but takes a non-nullable SqlExpression placed
--   at the end of the SqlExpression list, which guarantees a non-NULL
--   result.
--   
--   <i>Since: 1.4.3</i>
coalesceDefault :: PersistField a => [SqlExpr (Value (Maybe a))] -> SqlExpr (Value a) -> SqlExpr (Value a)

-- | <tt>LOWER</tt> function.
lower_ :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s)

-- | <tt>LIKE</tt> operator.
like :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s) -> SqlExpr (Value Bool)
infixr 2 `like`

-- | <tt>ILIKE</tt> operator (case-insensitive <tt>LIKE</tt>).
--   
--   Supported by PostgreSQL only.
--   
--   <i>Since: 2.2.3</i>
ilike :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s) -> SqlExpr (Value Bool)
infixr 2 `ilike`

-- | The string <tt><a>%</a></tt>. May be useful while using <a>like</a>
--   and concatenation (<a>concat_</a> or <a>++.</a>, depending on your
--   database). Note that you always have to type the parenthesis, for
--   example:
--   
--   <pre>
--   name `<a>like</a>` (%) ++. <a>val</a> "John" ++. (%)
--   </pre>
(%) :: SqlString s => SqlExpr (Value s)

-- | The <tt>CONCAT</tt> function with a variable number of parameters.
--   Supported by MySQL and PostgreSQL.
concat_ :: SqlString s => [SqlExpr (Value s)] -> SqlExpr (Value s)

-- | The <tt>||</tt> string concatenation operator (named after Haskell's
--   <a>++</a> in order to avoid naming clash with <a>||.</a>). Supported
--   by SQLite and PostgreSQL.
(++.) :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s) -> SqlExpr (Value s)
infixr 5 ++.

-- | Cast a string type into <tt>Text</tt>. This function is very useful if
--   you want to use <tt>newtype</tt>s, or if you want to apply functions
--   such as <a>like</a> to strings of different types.
--   
--   <i>Safety:</i> This is a slightly unsafe function, especially if you
--   have defined your own instances of <a>SqlString</a>. Also, since
--   <a>Maybe</a> is an instance of <a>SqlString</a>, it's possible to turn
--   a nullable value into a non-nullable one. Avoid using this function if
--   possible.
castString :: (SqlString s, SqlString r) => SqlExpr (Value s) -> SqlExpr (Value r)

-- | Execute a subquery <tt>SELECT</tt> in an SqlExpression. Returns a list
--   of values.
subList_select :: PersistField a => SqlQuery (SqlExpr (Value a)) -> SqlExpr (ValueList a)

-- | Lift a list of constant value from Haskell-land to the query.
valList :: PersistField typ => [typ] -> SqlExpr (ValueList typ)

-- | Same as <a>just</a> but for <a>ValueList</a>. Most of the time you
--   won't need it, though, because you can use <a>just</a> from inside
--   <a>subList_select</a> or <a>Just</a> from inside <a>valList</a>.
--   
--   <i>Since: 2.2.12</i>
justList :: SqlExpr (ValueList typ) -> SqlExpr (ValueList (Maybe typ))

-- | <tt>IN</tt> operator. For example if you want to select all
--   <tt>Person</tt>s by a list of IDs:
--   
--   <pre>
--   SELECT *
--   FROM Person
--   WHERE Person.id IN (?)
--   </pre>
--   
--   In <tt>esqueleto</tt>, we may write the same query above as:
--   
--   <pre>
--   select $
--   <a>from</a> $ \person -&gt; do
--   <a>where_</a> $ person <a>^.</a> PersonId `<a>in_</a>` <a>valList</a> personIds
--   return person
--   </pre>
--   
--   Where <tt>personIds</tt> is of type <tt>[Key Person]</tt>.
in_ :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (ValueList typ) -> SqlExpr (Value Bool)

-- | <tt>NOT IN</tt> operator.
notIn :: PersistField typ => SqlExpr (Value typ) -> SqlExpr (ValueList typ) -> SqlExpr (Value Bool)

-- | <tt>EXISTS</tt> operator. For example:
--   
--   <pre>
--   select $
--   <a>from</a> $ \person -&gt; do
--   <a>where_</a> $ <a>exists</a> $
--            <a>from</a> $ \post -&gt; do
--            <a>where_</a> (post <a>^.</a> BlogPostAuthorId <a>==.</a> person <a>^.</a> PersonId)
--   return person
--   </pre>
exists :: SqlQuery () -> SqlExpr (Value Bool)

-- | <tt>NOT EXISTS</tt> operator.
notExists :: SqlQuery () -> SqlExpr (Value Bool)

-- | <tt>SET</tt> clause used on <tt>UPDATE</tt>s. Note that while it's not
--   a type error to use this function on a <tt>SELECT</tt>, it will most
--   certainly result in a runtime error.
set :: PersistEntity val => SqlExpr (Entity val) -> [SqlExpr (Update val)] -> SqlQuery ()
(=.) :: (PersistEntity val, PersistField typ) => EntityField val typ -> SqlExpr (Value typ) -> SqlExpr (Update val)
infixr 3 =.
(+=.) :: (PersistEntity val, PersistField a) => EntityField val a -> SqlExpr (Value a) -> SqlExpr (Update val)
infixr 3 +=.
(-=.) :: (PersistEntity val, PersistField a) => EntityField val a -> SqlExpr (Value a) -> SqlExpr (Update val)
infixr 3 -=.
(*=.) :: (PersistEntity val, PersistField a) => EntityField val a -> SqlExpr (Value a) -> SqlExpr (Update val)
infixr 3 *=.
(/=.) :: (PersistEntity val, PersistField a) => EntityField val a -> SqlExpr (Value a) -> SqlExpr (Update val)
infixr 3 /=.

-- | <tt>CASE</tt> statement. For example:
--   
--   <pre>
--   select $
--   return $
--   <a>case_</a>
--      [ <a>when_</a>
--          (<a>exists</a> $
--          <a>from</a> $ \p -&gt; do
--          <a>where_</a> (p <a>^.</a> PersonName <a>==.</a> <a>val</a> "Mike"))
--        <a>then_</a>
--          (<a>sub_select</a> $
--          <a>from</a> $ \v -&gt; do
--          let sub =
--                  <a>from</a> $ \c -&gt; do
--                  <a>where_</a> (c <a>^.</a> PersonName <a>==.</a> <a>val</a> "Mike")
--                  return (c <a>^.</a> PersonFavNum)
--          <a>where_</a> (v <a>^.</a> PersonFavNum &gt;. <a>sub_select</a> sub)
--          return $ <a>count</a> (v <a>^.</a> PersonName) +. <a>val</a> (1 :: Int)) ]
--      (<a>else_</a> $ <a>val</a> (-1))
--   </pre>
--   
--   This query is a bit complicated, but basically it checks if a person
--   named <tt>"Mike"</tt> exists, and if that person does, run the
--   subquery to find out how many people have a ranking (by Fav Num)
--   higher than <tt>"Mike"</tt>.
--   
--   <b>NOTE:</b> There are a few things to be aware about this statement.
--   
--   <ul>
--   <li>This only implements the full CASE statement, it does not
--   implement the "simple" CASE statement.</li>
--   <li>At least one <a>when_</a> and <a>then_</a> is mandatory otherwise
--   it will emit an error.</li>
--   <li>The <a>else_</a> is also mandatory, unlike the SQL statement in
--   which if the <tt>ELSE</tt> is omitted it will return a <tt>NULL</tt>.
--   You can reproduce this via <a>nothing</a>.</li>
--   </ul>
--   
--   <i>Since: 2.1.2</i>
case_ :: PersistField a => [(SqlExpr (Value Bool), SqlExpr (Value a))] -> SqlExpr (Value a) -> SqlExpr (Value a)

-- | Convert an entity's key into another entity's.
--   
--   This function is to be used when you change an entity's <tt>Id</tt> to
--   be that of another entity. For example:
--   
--   <pre>
--   Bar
--     barNum Int
--   Foo
--     Id BarId
--     fooNum Int
--   </pre>
--   
--   For this example, declare:
--   
--   <pre>
--   instance ToBaseId Foo where
--     type BaseEnt Foo = Bar
--     toBaseIdWitness = FooKey
--   </pre>
--   
--   Now you're able to write queries such as:
--   
--   <pre>
--   <a>select</a> $
--   <a>from</a> $ (bar `<a>InnerJoin</a>` foo) -&gt; do
--   <a>on</a> (<a>toBaseId</a> (foo <a>^.</a> FooId) <a>==.</a> bar <a>^.</a> BarId)
--   return (bar, foo)
--   </pre>
--   
--   Note: this function may be unsafe to use in conditions not like the
--   one of the example above.
--   
--   <i>Since: 2.4.3</i>
toBaseId :: ToBaseId ent => SqlExpr (Value (Key ent)) -> SqlExpr (Value (Key (BaseEnt ent)))

-- | Class that enables one to use <a>toBaseId</a> to convert an entity's
--   key on a query into another (cf. <a>toBaseId</a>).
class ToBaseId ent where {
    type family BaseEnt ent :: *;
}
toBaseIdWitness :: ToBaseId ent => Key (BaseEnt ent) -> Key ent

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
when_ :: expr (Value Bool) -> () -> expr a -> (expr (Value Bool), expr a)

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
then_ :: ()

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
else_ :: expr a -> expr a

-- | <tt>FROM</tt> clause: bring entities into scope.
--   
--   This function internally uses two type classes in order to provide
--   some flexibility of how you may call it. Internally we refer to these
--   type classes as the two different magics.
--   
--   The innermost magic allows you to use <tt>from</tt> with the following
--   types:
--   
--   <ul>
--   <li><tt>expr (Entity val)</tt>, which brings a single entity into
--   scope.</li>
--   <li><tt>expr (Maybe (Entity val))</tt>, which brings a single entity
--   that may be <tt>NULL</tt> into scope. Used for <tt>OUTER
--   JOIN</tt>s.</li>
--   <li>A <tt>JOIN</tt> of any other two types allowed by the innermost
--   magic, where a <tt>JOIN</tt> may be an <a>InnerJoin</a>, a
--   <a>CrossJoin</a>, a <a>LeftOuterJoin</a>, a <a>RightOuterJoin</a>, or
--   a <a>FullOuterJoin</a>. The <tt>JOINs</tt> have left fixity.</li>
--   </ul>
--   
--   The outermost magic allows you to use <tt>from</tt> on any tuples of
--   types supported by innermost magic (and also tuples of tuples, and so
--   on), up to 8-tuples.
--   
--   Note that using <tt>from</tt> for the same entity twice does work and
--   corresponds to a self-join. You don't even need to use two different
--   calls to <tt>from</tt>, you may use a <tt>JOIN</tt> or a tuple.
--   
--   The following are valid examples of uses of <tt>from</tt> (the types
--   of the arguments of the lambda are inside square brackets):
--   
--   <pre>
--   <a>from</a> $ \person -&gt; ...
--   <a>from</a> $ \(person, blogPost) -&gt; ...
--   <a>from</a> $ \(p `<a>LeftOuterJoin</a>` mb) -&gt; ...
--   <a>from</a> $ \(p1 `<a>InnerJoin</a>` f `<a>InnerJoin</a>` p2) -&gt; ...
--   <a>from</a> $ \((p1 `<a>InnerJoin</a>` f) `<a>InnerJoin</a>` p2) -&gt; ...
--   </pre>
--   
--   The types of the arguments to the lambdas above are, respectively:
--   
--   <pre>
--   person
--     :: ( Esqueleto query expr backend
--        , PersistEntity Person
--        , PersistEntityBackend Person ~ backend
--        ) =&gt; expr (Entity Person)
--   (person, blogPost)
--     :: (...) =&gt; (expr (Entity Person), expr (Entity BlogPost))
--   (p `<a>LeftOuterJoin</a>` mb)
--     :: (...) =&gt; InnerJoin (expr (Entity Person)) (expr (Maybe (Entity BlogPost)))
--   (p1 `<a>InnerJoin</a>` f `<a>InnerJoin</a>` p2)
--     :: (...) =&gt; InnerJoin
--                   (InnerJoin (expr (Entity Person))
--                              (expr (Entity Follow)))
--                   (expr (Entity Person))
--   (p1 `<a>InnerJoin</a>` (f `<a>InnerJoin</a>` p2)) ::
--     :: (...) =&gt; InnerJoin
--                   (expr (Entity Person))
--                   (InnerJoin (expr (Entity Follow))
--                              (expr (Entity Person)))
--   </pre>
--   
--   Note that some backends may not support all kinds of <tt>JOIN</tt>s.
from :: From a => (a -> SqlQuery b) -> SqlQuery b

-- | A single value (as opposed to a whole entity). You may use
--   <tt>(<a>^.</a>)</tt> or <tt>(<a>?.</a>)</tt> to get a <a>Value</a>
--   from an <a>Entity</a>.
newtype Value a
Value :: a -> Value a
[unValue] :: Value a -> a

-- | A list of single values. There's a limited set of functions able to
--   work with this data type (such as <a>subList_select</a>,
--   <a>valList</a>, <a>in_</a> and <a>exists</a>).
newtype ValueList a
ValueList :: a -> ValueList a

-- | Phantom type used by <a>orderBy</a>, <a>asc</a> and <a>desc</a>.
data OrderBy

-- | Phantom type used by <a>distinctOn</a> and <a>don</a>.
data DistinctOn

-- | Different kinds of locking clauses supported by <a>locking</a>.
--   
--   Note that each RDBMS has different locking support. The constructors
--   of this datatype specify only the <i>syntax</i> of the locking
--   mechanism, not its <i>semantics</i>. For example, even though both
--   MySQL and PostgreSQL support <a>ForUpdate</a>, there are no guarantees
--   that they will behave the same.
--   
--   <i>Since: 2.2.7</i>
data LockingKind

-- | <tt>FOR UPDATE</tt> syntax. Supported by MySQL, Oracle and PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForUpdate :: LockingKind

-- | <tt>FOR UPDATE SKIP LOCKED</tt> syntax. Supported by MySQL, Oracle and
--   PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForUpdateSkipLocked :: LockingKind

-- | <tt>FOR SHARE</tt> syntax. Supported by PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForShare :: LockingKind

-- | <tt>LOCK IN SHARE MODE</tt> syntax. Supported by MySQL.
--   
--   <i>Since: 2.2.7</i>
LockInShareMode :: LockingKind

-- | Phantom class of data types that are treated as strings by the RDBMS.
--   It has no methods because it's only used to avoid type errors such as
--   trying to concatenate integers.
--   
--   If you have a custom data type or <tt>newtype</tt>, feel free to make
--   it an instance of this class.
--   
--   <i>Since: 2.4.0</i>
class PersistField a => SqlString a

-- | Data type that represents an <tt>INNER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data InnerJoin a b
InnerJoin :: a -> b -> InnerJoin a b
infixl 2 `InnerJoin`
infixl 2 `InnerJoin`

-- | Data type that represents a <tt>CROSS JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data CrossJoin a b
CrossJoin :: a -> b -> CrossJoin a b
infixl 2 `CrossJoin`
infixl 2 `CrossJoin`

-- | Data type that represents a <tt>LEFT OUTER JOIN</tt>. For example,
--   
--   <pre>
--   select $
--   <a>from</a> $ \(person `<a>LeftOuterJoin</a>` pet) -&gt;
--     ...
--   </pre>
--   
--   is translated into
--   
--   <pre>
--   SELECT ...
--   FROM Person LEFT OUTER JOIN Pet
--   ...
--   </pre>
--   
--   See also: <a>from</a>.
data LeftOuterJoin a b
LeftOuterJoin :: a -> b -> LeftOuterJoin a b
infixl 2 `LeftOuterJoin`
infixl 2 `LeftOuterJoin`

-- | Data type that represents a <tt>RIGHT OUTER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data RightOuterJoin a b
RightOuterJoin :: a -> b -> RightOuterJoin a b
infixl 2 `RightOuterJoin`
infixl 2 `RightOuterJoin`

-- | Data type that represents a <tt>FULL OUTER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data FullOuterJoin a b
FullOuterJoin :: a -> b -> FullOuterJoin a b
infixl 2 `FullOuterJoin`
infixl 2 `FullOuterJoin`

-- | Exception thrown whenever <a>on</a> is used to create an <tt>ON</tt>
--   clause but no matching <tt>JOIN</tt> is found.
data OnClauseWithoutMatchingJoinException
OnClauseWithoutMatchingJoinException :: String -> OnClauseWithoutMatchingJoinException

-- | SQL backend for <tt>esqueleto</tt> using <a>SqlPersistT</a>.
data SqlQuery a

-- | An expression on the SQL backend.
--   
--   There are many comments describing the constructors of this data type.
--   However, Haddock doesn't like GADTs, so you'll have to read them by
--   hitting "Source".
data SqlExpr a

-- | Constraint synonym for <tt>persistent</tt> entities whose backend is
--   <a>SqlPersistT</a>.
type SqlEntity ent = (PersistEntity ent, PersistEntityBackend ent ~ SqlBackend)

-- | Execute an <tt>esqueleto</tt> <tt>SELECT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a list of
--   rows.
--   
--   We've seen that <a>from</a> has some magic about which kinds of things
--   you may bring into scope. This <a>select</a> function also has some
--   magic for which kinds of things you may bring back to Haskell-land by
--   using <tt>SqlQuery</tt>'s <tt>return</tt>:
--   
--   <ul>
--   <li>You may return a <tt>SqlExpr (<a>Entity</a> v)</tt> for an entity
--   <tt>v</tt> (i.e., like the <tt>*</tt> in SQL), which is then returned
--   to Haskell-land as just <tt>Entity v</tt>.</li>
--   <li>You may return a <tt>SqlExpr (Maybe (Entity v))</tt> for an entity
--   <tt>v</tt> that may be <tt>NULL</tt>, which is then returned to
--   Haskell-land as <tt>Maybe (Entity v)</tt>. Used for <tt>OUTER
--   JOIN</tt>s.</li>
--   <li>You may return a <tt>SqlExpr (<a>Value</a> t)</tt> for a value
--   <tt>t</tt> (i.e., a single column), where <tt>t</tt> is any instance
--   of <a>PersistField</a>, which is then returned to Haskell-land as
--   <tt>Value t</tt>. You may use <tt>Value</tt> to return projections of
--   an <tt>Entity</tt> (see <tt>(<a>^.</a>)</tt> and <tt>(<a>?.</a>)</tt>)
--   or to return any other value calculated on the query (e.g.,
--   <a>countRows</a> or <a>sub_select</a>).</li>
--   </ul>
--   
--   The <tt>SqlSelect a r</tt> class has functional dependencies that
--   allow type information to flow both from <tt>a</tt> to <tt>r</tt> and
--   vice-versa. This means that you'll almost never have to give any type
--   signatures for <tt>esqueleto</tt> queries. For example, the query
--   <tt><a>select</a> $ from $ \p -&gt; return p</tt> alone is ambiguous,
--   but in the context of
--   
--   <pre>
--   do ps &lt;- <a>select</a> $
--            <a>from</a> $ \p -&gt;
--            return p
--      liftIO $ mapM_ (putStrLn . personName . entityVal) ps
--   </pre>
--   
--   we are able to infer from that single <tt>personName . entityVal</tt>
--   function composition that the <tt>p</tt> inside the query is of type
--   <tt>SqlExpr (Entity Person)</tt>.
select :: (SqlSelect a r, MonadIO m) => SqlQuery a -> SqlReadT m [r]

-- | Execute an <tt>esqueleto</tt> <tt>SELECT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a
--   <a>Source</a> of rows.
selectSource :: (SqlSelect a r, BackendCompatible SqlBackend backend, IsPersistBackend backend, PersistQueryRead backend, PersistStoreRead backend, PersistUniqueRead backend, MonadResource m) => SqlQuery a -> ConduitT () r (ReaderT backend m) ()

-- | Execute an <tt>esqueleto</tt> <tt>DELETE</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad. Note that currently
--   there are no type checks for statements that should not appear on a
--   <tt>DELETE</tt> query.
--   
--   Example of usage:
--   
--   <pre>
--   <a>delete</a> $
--   <a>from</a> $ \appointment -&gt;
--   <a>where_</a> (appointment <a>^.</a> AppointmentDate <a>&lt;.</a> <a>val</a> now)
--   </pre>
--   
--   Unlike <a>select</a>, there is a useful way of using <a>delete</a>
--   that will lead to type ambiguities. If you want to delete all rows
--   (i.e., no <a>where_</a> clause), you'll have to use a type signature:
--   
--   <pre>
--   <a>delete</a> $
--   <a>from</a> $ \(appointment :: <a>SqlExpr</a> (<a>Entity</a> Appointment)) -&gt;
--   return ()
--   </pre>
delete :: MonadIO m => SqlQuery () -> SqlWriteT m ()

-- | Same as <a>delete</a>, but returns the number of rows affected.
deleteCount :: MonadIO m => SqlQuery () -> SqlWriteT m Int64

-- | Execute an <tt>esqueleto</tt> <tt>UPDATE</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad. Note that currently
--   there are no type checks for statements that should not appear on a
--   <tt>UPDATE</tt> query.
--   
--   Example of usage:
--   
--   <pre>
--   <a>update</a> $ \p -&gt; do
--   <a>set</a> p [ PersonAge <a>=.</a> <a>just</a> (<a>val</a> thisYear) -. p <a>^.</a> PersonBorn ]
--   <a>where_</a> $ isNothing (p <a>^.</a> PersonAge)
--   </pre>
update :: (MonadIO m, PersistEntity val, BackendCompatible SqlBackend (PersistEntityBackend val)) => (SqlExpr (Entity val) -> SqlQuery ()) -> SqlWriteT m ()

-- | Same as <a>update</a>, but returns the number of rows affected.
updateCount :: (MonadIO m, PersistEntity val, BackendCompatible SqlBackend (PersistEntityBackend val)) => (SqlExpr (Entity val) -> SqlQuery ()) -> SqlWriteT m Int64

-- | Insert a <a>PersistField</a> for every selected value.
--   
--   <i>Since: 2.4.2</i>
insertSelect :: (MonadIO m, PersistEntity a) => SqlQuery (SqlExpr (Insertion a)) -> SqlWriteT m ()

-- | Insert a <a>PersistField</a> for every selected value, return the
--   count afterward
insertSelectCount :: (MonadIO m, PersistEntity a) => SqlQuery (SqlExpr (Insertion a)) -> SqlWriteT m Int64

-- | Apply a <a>PersistField</a> constructor to <tt>SqlExpr Value</tt>
--   arguments.
(<#) :: (a -> b) -> SqlExpr (Value a) -> SqlExpr (Insertion b)

-- | Apply extra <tt>SqlExpr Value</tt> arguments to a <a>PersistField</a>
--   constructor
(<&>) :: SqlExpr (Insertion (a -> b)) -> SqlExpr (Value a) -> SqlExpr (Insertion b)

-- | (Internal) Class that implements the tuple <a>from</a> magic (see
--   <a>fromStart</a>).
class From a

-- | <tt>valkey i = <a>val</a> . <a>toSqlKey</a></tt>
--   (<a>https://github.com/prowdsponsor/esqueleto/issues/9</a>).
valkey :: (ToBackendKey SqlBackend entity, PersistField (Key entity)) => Int64 -> SqlExpr (Value (Key entity))

-- | <tt>valJ</tt> is like <tt>val</tt> but for something that is already a
--   <tt>Value</tt>. The use case it was written for was, given a
--   <tt>Value</tt> lift the <tt>Key</tt> for that <tt>Value</tt> into the
--   query expression in a type safe way. However, the implementation is
--   more generic than that so we call it <tt>valJ</tt>.
--   
--   Its important to note that the input entity and the output entity are
--   constrained to be the same by the type signature on the function
--   (<a>https://github.com/prowdsponsor/esqueleto/pull/69</a>).
--   
--   <i>Since: 1.4.2</i>
valJ :: PersistField (Key entity) => Value (Key entity) -> SqlExpr (Value (Key entity))

-- | Synonym for <a>delete</a> that does not clash with
--   <tt>esqueleto</tt>'s <a>delete</a>.
deleteKey :: (PersistStore backend, BaseBackend backend ~ PersistEntityBackend val, MonadIO m, PersistEntity val) => Key val -> ReaderT backend m ()

-- | A more general way to convert instances of <a>ToJSON</a> type class to
--   strict text <a>Text</a>.
toJsonText :: ToJSON j => j -> Text

-- | Predefined <tt>parseJSON</tt>. The input JSON looks like <tt>{"id": 1,
--   "name": ...}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance FromJSON (Entity User) where
--       parseJSON = entityIdFromJSON
--   </pre>
entityIdFromJSON :: (PersistEntity record, FromJSON record, FromJSON (Key record)) => Value -> Parser (Entity record)

-- | Predefined <tt>toJSON</tt>. The resulting JSON looks like <tt>{"id":
--   1, "name": ...}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance ToJSON (Entity User) where
--       toJSON = entityIdToJSON
--   </pre>
entityIdToJSON :: (PersistEntity record, ToJSON record, ToJSON (Key record)) => Entity record -> Value

-- | Get list of values corresponding to given entity.
entityValues :: PersistEntity record => Entity record -> [PersistValue]

-- | Convenience function for getting a free <a>PersistField</a> instance
--   from a type with JSON instances. The JSON parser used will accept JSON
--   values other that object and arrays. So, if your instance serializes
--   the data to a JSON string, this will still work.
--   
--   Example usage in combination with <a>toPersistValueJSON</a>:
--   
--   <pre>
--   instance PersistField MyData where
--     fromPersistValue = fromPersistValueJSON
--     toPersistValue = toPersistValueJSON
--   </pre>
fromPersistValueJSON :: FromJSON a => PersistValue -> Either Text a

-- | Predefined <tt>parseJSON</tt>. The input JSON looks like <tt>{"key":
--   1, "value": {"name": ...}}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance FromJSON (Entity User) where
--       parseJSON = keyValueEntityFromJSON
--   </pre>
keyValueEntityFromJSON :: (PersistEntity record, FromJSON record, FromJSON (Key record)) => Value -> Parser (Entity record)

-- | Predefined <tt>toJSON</tt>. The resulting JSON looks like <tt>{"key":
--   1, "value": {"name": ...}}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance ToJSON (Entity User) where
--       toJSON = keyValueEntityToJSON
--   </pre>
keyValueEntityToJSON :: (PersistEntity record, ToJSON record, ToJSON (Key record)) => Entity record -> Value

-- | Convenience function for getting a free <a>PersistField</a> instance
--   from a type with JSON instances.
--   
--   Example usage in combination with <a>fromPersistValueJSON</a>:
--   
--   <pre>
--   instance PersistField MyData where
--     fromPersistValue = fromPersistValueJSON
--     toPersistValue = toPersistValueJSON
--   </pre>
toPersistValueJSON :: ToJSON a => a -> PersistValue

-- | Get the <a>Key</a>s of all records matching the given criterion.
selectKeys :: (PersistQueryRead (BaseBackend backend), MonadResource m, PersistEntity record, BaseBackend (BaseBackend backend) ~ PersistEntityBackend record, MonadReader backend m, HasPersistBackend backend) => [Filter record] -> [SelectOpt record] -> ConduitM () (Key record) m ()

-- | Curry this to make a convenience function that loads an associated
--   model.
--   
--   <pre>
--   foreign = belongsTo foreignId
--   </pre>
belongsTo :: (PersistStoreRead backend, PersistEntity ent1, PersistRecordBackend ent2 backend, MonadIO m) => (ent1 -> Maybe (Key ent2)) -> ent1 -> ReaderT backend m (Maybe ent2)

-- | Same as <a>belongsTo</a>, but uses <tt>getJust</tt> and therefore is
--   similarly unsafe.
belongsToJust :: (PersistStoreRead backend, PersistEntity ent1, PersistRecordBackend ent2 backend, MonadIO m) => (ent1 -> Key ent2) -> ent1 -> ReaderT backend m ent2

-- | Like <tt>get</tt>, but returns the complete <tt>Entity</tt>.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   getSpjEntity :: MonadIO m =&gt; ReaderT SqlBackend m (Maybe (Entity User))
--   getSpjEntity = getEntity spjId
--   </pre>
--   
--   <pre>
--   mSpjEnt &lt;- getSpjEntity
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will get this
--   entity:
--   
--   <pre>
--   +----+------+-----+
--   | id | name | age |
--   +----+------+-----+
--   |  1 | SPJ  |  40 |
--   +----+------+-----+
--   </pre>
getEntity :: (PersistStoreRead backend, PersistRecordBackend e backend, MonadIO m) => Key e -> ReaderT backend m (Maybe (Entity e))

-- | Same as <a>get</a>, but for a non-null (not Maybe) foreign key. Unsafe
--   unless your database is enforcing that the foreign key is valid.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   getJustSpj :: MonadIO m =&gt; ReaderT SqlBackend m User
--   getJustSpj = getJust spjId
--   </pre>
--   
--   <pre>
--   spj &lt;- getJust spjId
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will get this
--   record:
--   
--   <pre>
--   +----+------+-----+
--   | id | name | age |
--   +----+------+-----+
--   |  1 | SPJ  |  40 |
--   +----+------+-----+
--   </pre>
--   
--   <pre>
--   getJustUnknown :: MonadIO m =&gt; ReaderT SqlBackend m User
--   getJustUnknown = getJust unknownId
--   </pre>
--   
--   mrx &lt;- getJustUnknown
--   
--   This just throws an error.
getJust :: (PersistStoreRead backend, Show (Key record), PersistRecordBackend record backend, MonadIO m) => Key record -> ReaderT backend m record

-- | Same as <a>getJust</a>, but returns an <a>Entity</a> instead of just
--   the record.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   getJustEntitySpj :: MonadIO m =&gt; ReaderT SqlBackend m (Entity User)
--   getJustEntitySpj = getJustEntity spjId
--   </pre>
--   
--   <pre>
--   spjEnt &lt;- getJustEntitySpj
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will get this
--   entity:
--   
--   <pre>
--   +----+------+-----+
--   | id | name | age |
--   +----+------+-----+
--   |  1 | SPJ  |  40 |
--   +----+------+-----+
--   </pre>
getJustEntity :: (PersistEntityBackend record ~ BaseBackend backend, MonadIO m, PersistEntity record, PersistStoreRead backend) => Key record -> ReaderT backend m (Entity record)

-- | Like <tt>insert</tt>, but returns the complete <tt>Entity</tt>.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   insertHaskellEntity :: MonadIO m =&gt; ReaderT SqlBackend m (Entity User)
--   insertHaskellEntity = insertEntity $ User "Haskell" 81
--   </pre>
--   
--   <pre>
--   haskellEnt &lt;- insertHaskellEntity
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +----+---------+-----+
--   | id |  name   | age |
--   +----+---------+-----+
--   |  1 | SPJ     |  40 |
--   +----+---------+-----+
--   |  2 | Simon   |  41 |
--   +----+---------+-----+
--   |  3 | Haskell |  81 |
--   +----+---------+-----+
--   </pre>
insertEntity :: (PersistStoreWrite backend, PersistRecordBackend e backend, MonadIO m) => e -> ReaderT backend m (Entity e)

-- | Like <a>insertEntity</a> but just returns the record instead of
--   <a>Entity</a>.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   insertDaveRecord :: MonadIO m =&gt; ReaderT SqlBackend m User
--   insertDaveRecord = insertRecord $ User "Dave" 50
--   </pre>
--   
--   <pre>
--   dave &lt;- insertDaveRecord
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |Dave  |50   |
--   +-----+------+-----+
--   </pre>
insertRecord :: (PersistEntityBackend record ~ BaseBackend backend, PersistEntity record, MonadIO m, PersistStoreWrite backend) => record -> ReaderT backend m record
liftPersist :: (MonadIO m, MonadReader backend m, HasPersistBackend backend) => ReaderT (BaseBackend backend) IO b -> m b

-- | Check whether there are any conflicts for unique keys with this entity
--   and existing entities in the database.
--   
--   Returns <a>Nothing</a> if the entity would be unique, and could thus
--   safely be inserted. on a conflict returns the conflicting key
--   
--   <h3><b>Example usage</b></h3>
--   
--   We use <a>schema-1</a> and <a>dataset-1</a> here.
--   
--   This would be <a>Nothing</a>:
--   
--   <pre>
--   mAlanConst &lt;- checkUnique $ User "Alan" 70
--   </pre>
--   
--   While this would be <a>Just</a> because SPJ already exists:
--   
--   <pre>
--   mSpjConst &lt;- checkUnique $ User "SPJ" 60
--   </pre>
checkUnique :: (MonadIO m, PersistRecordBackend record backend, PersistUniqueRead backend) => record -> ReaderT backend m (Maybe (Unique record))

-- | A modification of <a>getBy</a>, which takes the <a>PersistEntity</a>
--   itself instead of a <a>Unique</a> record. Returns a record matching
--   <i>one</i> of the unique keys. This function makes the most sense on
--   entities with a single <a>Unique</a> constructor.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   getBySpjValue :: MonadIO m =&gt; ReaderT SqlBackend m (Maybe (Entity
--   User)) getBySpjValue = getByValue $ User <a>SPJ</a> 999
--   
--   <pre>
--   mSpjEnt &lt;- getBySpjValue
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will get this
--   record:
--   
--   <pre>
--   +----+------+-----+
--   | id | name | age |
--   +----+------+-----+
--   |  1 | SPJ  |  40 |
--   +----+------+-----+
--   </pre>
getByValue :: (MonadIO m, PersistUniqueRead backend, PersistRecordBackend record backend) => record -> ReaderT backend m (Maybe (Entity record))

-- | Insert a value, checking for conflicts with any unique constraints. If
--   a duplicate exists in the database, it is returned as <a>Left</a>.
--   Otherwise, the new 'Key is returned as <a>Right</a>.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-2</a> and <a>dataset-1</a>, we have following lines of
--   code:
--   
--   <pre>
--   l1 &lt;- insertBy $ User "SPJ" 20
--   l2 &lt;- insertBy $ User "XXX" 41
--   l3 &lt;- insertBy $ User "SPJ" 40
--   r1 &lt;- insertBy $ User "XXX" 100
--   </pre>
--   
--   First three lines return <a>Left</a> because there're duplicates in
--   given record's uniqueness constraints. While the last line returns a
--   new key as <a>Right</a>.
insertBy :: (MonadIO m, PersistUniqueWrite backend, PersistRecordBackend record backend) => record -> ReaderT backend m (Either (Entity record) (Key record))

-- | Like <a>insertEntity</a>, but returns <a>Nothing</a> when the record
--   couldn't be inserted because of a uniqueness constraint.
--   
--   <h3><b>Example usage</b></h3>
--   
--   We use <a>schema-2</a> and <a>dataset-1</a> here.
--   
--   <pre>
--   insertUniqueSpjEntity :: MonadIO m =&gt; ReaderT SqlBackend m (Maybe (Entity User))
--   insertUniqueSpjEntity = insertUniqueEntity $ User "SPJ" 50
--   </pre>
--   
--   <pre>
--   mSpjEnt &lt;- insertUniqueSpjEntity
--   </pre>
--   
--   The above query results <a>Nothing</a> as SPJ already exists.
--   
--   <pre>
--   insertUniqueAlexaEntity :: MonadIO m =&gt; ReaderT SqlBackend m (Maybe (Entity User))
--   insertUniqueAlexaEntity = insertUniqueEntity $ User "Alexa" 3
--   </pre>
--   
--   <pre>
--   mAlexaEnt &lt;- insertUniqueSpjEntity
--   </pre>
--   
--   Because there's no such unique keywords of the given record, the above
--   query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +----+-------+-----+
--   | id | name  | age |
--   +----+-------+-----+
--   |  1 | SPJ   |  40 |
--   +----+-------+-----+
--   |  2 | Simon |  41 |
--   +----+-------+-----+
--   |  3 | Alexa |   3 |
--   +----+-------+-----+
--   </pre>
insertUniqueEntity :: (MonadIO m, PersistRecordBackend record backend, PersistUniqueWrite backend) => record -> ReaderT backend m (Maybe (Entity record))

-- | Return the single unique key for a record.
--   
--   <h3><b>Example usage</b></h3>
--   
--   We use shcema-1 and <a>dataset-1</a> here.
--   
--   <pre>
--   onlySimonConst :: MonadIO m =&gt; ReaderT SqlBackend m (Unique User)
--   onlySimonConst = onlyUnique $ User "Simon" 999
--   </pre>
--   
--   <pre>
--   mSimonConst &lt;- onlySimonConst
--   </pre>
--   
--   <tt>mSimonConst</tt> would be Simon's uniqueness constraint. Note that
--   <tt>onlyUnique</tt> doesn't work if there're more than two
--   constraints.
onlyUnique :: (MonadIO m, PersistUniqueWrite backend, PersistRecordBackend record backend) => record -> ReaderT backend m (Unique record)

-- | Attempt to replace the record of the given key with the given new
--   record. First query the unique fields to make sure the replacement
--   maintains uniqueness constraints.
--   
--   Return <a>Nothing</a> if the replacement was made. If uniqueness is
--   violated, return a <a>Just</a> with the <a>Unique</a> violation
replaceUnique :: (MonadIO m, Eq record, Eq (Unique record), PersistRecordBackend record backend, PersistUniqueWrite backend) => Key record -> record -> ReaderT backend m (Maybe (Unique record))

-- | Commit the current transaction and begin a new one.
transactionSave :: MonadIO m => ReaderT SqlBackend m ()

-- | Roll back the current transaction and begin a new one.
transactionUndo :: MonadIO m => ReaderT SqlBackend m ()
defaultAttribute :: [Attr] -> Maybe Text

-- | Create the list of columns for the given entity.
mkColumns :: [EntityDef] -> EntityDef -> ([Column], [UniqueDef], [ForeignDef])

-- | Return all of the <a>Sql</a> values associated with the given
--   migration. Calls <a>error</a> if there's a parse error on any
--   migration.
getMigration :: MonadIO m => Migration -> ReaderT SqlBackend m [Sql]

-- | Given a list of old entity definitions and a new <a>EntityDef</a> in
--   <tt>val</tt>, this creates a <a>Migration</a> to update the old list
--   of definitions with the new one.
migrate :: [EntityDef] -> EntityDef -> Migration

-- | Given a <a>Migration</a>, this parses it and returns either a list of
--   errors associated with the migration or a list of migrations to do.
parseMigration :: MonadIO m => Migration -> ReaderT SqlBackend m (Either [Text] CautiousMigration)

-- | Like <a>parseMigration</a>, but instead of returning the value in an
--   <a>Either</a> value, it calls <a>error</a> on the error values.
parseMigration' :: MonadIO m => Migration -> ReaderT SqlBackend m CautiousMigration

-- | Prints a migration.
printMigration :: MonadIO m => Migration -> ReaderT SqlBackend m ()

-- | Runs a migration. If the migration fails to parse or if any of the
--   migrations are unsafe, then this calls <a>error</a> to halt the
--   program.
runMigration :: MonadIO m => Migration -> ReaderT SqlBackend m ()

-- | Same as <a>runMigration</a>, but returns a list of the SQL commands
--   executed instead of printing them to stderr.
runMigrationSilent :: (MonadUnliftIO m, MonadIO m) => Migration -> ReaderT SqlBackend m [Text]

-- | Like <a>runMigration</a>, but this will perform the unsafe database
--   migrations instead of erroring out.
runMigrationUnsafe :: MonadIO m => Migration -> ReaderT SqlBackend m ()

-- | Convert a <a>Migration</a> to a list of <a>Text</a> values
--   corresponding to their <a>Sql</a> statements.
showMigration :: MonadIO m => Migration -> ReaderT SqlBackend m [Text]

-- | Generates sql for limit and offset for postgres, sqlite and mysql.
decorateSQLWithLimitOffset :: Text -> (Int, Int) -> Bool -> Text -> Text

-- | useful for a backend to implement fieldName by adding escaping
fieldDBName :: PersistEntity record => EntityField record typ -> DBName
fromSqlKey :: ToBackendKey SqlBackend record => Key record -> Int64

-- | get the SQL string for the field that an EntityField represents Useful
--   for raw SQL queries
--   
--   Your backend may provide a more convenient fieldName function which
--   does not operate in a Monad
getFieldName :: (PersistEntity record, PersistEntityBackend record ~ SqlBackend, IsSqlBackend backend, Monad m) => EntityField record typ -> ReaderT backend m Text

-- | get the SQL string for the table that a PeristEntity represents Useful
--   for raw SQL queries
--   
--   Your backend may provide a more convenient tableName function which
--   does not operate in a Monad
getTableName :: (PersistEntity record, PersistEntityBackend record ~ SqlBackend, IsSqlBackend backend, Monad m) => record -> ReaderT backend m Text

-- | useful for a backend to implement tableName by adding escaping
tableDBName :: PersistEntity record => record -> DBName
toSqlKey :: ToBackendKey SqlBackend record => Int64 -> Key record
withRawQuery :: MonadIO m => Text -> [PersistValue] -> ConduitM [PersistValue] Void IO a -> ReaderT SqlBackend m a
getStmtConn :: SqlBackend -> Text -> IO Statement

-- | Execute a raw SQL statement
rawExecute :: (MonadIO m, BackendCompatible SqlBackend backend) => Text -> [PersistValue] -> ReaderT backend m ()

-- | Execute a raw SQL statement and return the number of rows it has
--   modified.
rawExecuteCount :: (MonadIO m, BackendCompatible SqlBackend backend) => Text -> [PersistValue] -> ReaderT backend m Int64
rawQuery :: (MonadResource m, MonadReader env m, HasPersistBackend env, BaseBackend env ~ SqlBackend) => Text -> [PersistValue] -> ConduitM () [PersistValue] m ()
rawQueryRes :: (MonadIO m1, MonadIO m2, IsSqlBackend env) => Text -> [PersistValue] -> ReaderT env m1 (Acquire (ConduitM () [PersistValue] m2 ()))

-- | Execute a raw SQL statement and return its results as a list.
--   
--   If you're using <a>Entity</a><tt>s</tt> (which is quite likely), then
--   you <i>must</i> use entity selection placeholders (double question
--   mark, <tt>??</tt>). These <tt>??</tt> placeholders are then replaced
--   for the names of the columns that we need for your entities. You'll
--   receive an error if you don't use the placeholders. Please see the
--   <a>Entity</a><tt>s</tt> documentation for more details.
--   
--   You may put value placeholders (question marks, <tt>?</tt>) in your
--   SQL query. These placeholders are then replaced by the values you pass
--   on the second parameter, already correctly escaped. You may want to
--   use <a>toPersistValue</a> to help you constructing the placeholder
--   values.
--   
--   Since you're giving a raw SQL statement, you don't get any guarantees
--   regarding safety. If <a>rawSql</a> is not able to parse the results of
--   your query back, then an exception is raised. However, most common
--   problems are mitigated by using the entity selection placeholder
--   <tt>??</tt>, and you shouldn't see any error at all if you're not
--   using <a>Single</a>.
--   
--   Some example of <a>rawSql</a> based on this schema:
--   
--   <pre>
--   share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
--   Person
--       name String
--       age Int Maybe
--       deriving Show
--   BlogPost
--       title String
--       authorId PersonId
--       deriving Show
--   |]
--   </pre>
--   
--   Examples based on the above schema:
--   
--   <pre>
--   getPerson :: MonadIO m =&gt; ReaderT SqlBackend m [Entity Person]
--   getPerson = rawSql "select ?? from person where name=?" [PersistText "john"]
--   
--   getAge :: MonadIO m =&gt; ReaderT SqlBackend m [Single Int]
--   getAge = rawSql "select person.age from person where name=?" [PersistText "john"]
--   
--   getAgeName :: MonadIO m =&gt; ReaderT SqlBackend m [(Single Int, Single Text)]
--   getAgeName = rawSql "select person.age, person.name from person where name=?" [PersistText "john"]
--   
--   getPersonBlog :: MonadIO m =&gt; ReaderT SqlBackend m [(Entity Person, Entity BlogPost)]
--   getPersonBlog = rawSql "select ??,?? from person,blog_post where person.id = blog_post.author_id" []
--   </pre>
--   
--   Minimal working program for PostgreSQL backend based on the above
--   concepts:
--   
--   <pre>
--   {-# LANGUAGE EmptyDataDecls             #-}
--   {-# LANGUAGE FlexibleContexts           #-}
--   {-# LANGUAGE GADTs                      #-}
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   {-# LANGUAGE MultiParamTypeClasses      #-}
--   {-# LANGUAGE OverloadedStrings          #-}
--   {-# LANGUAGE QuasiQuotes                #-}
--   {-# LANGUAGE TemplateHaskell            #-}
--   {-# LANGUAGE TypeFamilies               #-}
--   
--   import           Control.Monad.IO.Class  (liftIO)
--   import           Control.Monad.Logger    (runStderrLoggingT)
--   import           Database.Persist
--   import           Control.Monad.Reader
--   import           Data.Text
--   import           Database.Persist.Sql
--   import           Database.Persist.Postgresql
--   import           Database.Persist.TH
--   
--   share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
--   Person
--       name String
--       age Int Maybe
--       deriving Show
--   |]
--   
--   conn = "host=localhost dbname=new_db user=postgres password=postgres port=5432"
--   
--   getPerson :: MonadIO m =&gt; ReaderT SqlBackend m [Entity Person]
--   getPerson = rawSql "select ?? from person where name=?" [PersistText "sibi"]
--   
--   liftSqlPersistMPool y x = liftIO (runSqlPersistMPool y x)
--   
--   main :: IO ()
--   main = runStderrLoggingT $ withPostgresqlPool conn 10 $ liftSqlPersistMPool $ do
--            runMigration migrateAll
--            xs &lt;- getPerson
--            liftIO (print xs)
--   </pre>
rawSql :: (RawSql a, MonadIO m) => Text -> [PersistValue] -> ReaderT SqlBackend m [a]
askLogFunc :: (MonadUnliftIO m, MonadLogger m) => m LogFunc
close' :: IsSqlBackend backend => backend -> IO ()
createSqlPool :: (MonadLogger m, MonadUnliftIO m, IsSqlBackend backend) => (LogFunc -> IO backend) -> Int -> m (Pool backend)
liftSqlPersistMPool :: (MonadIO m, IsSqlBackend backend) => ReaderT backend (NoLoggingT (ResourceT IO)) a -> Pool backend -> m a
runSqlConn :: (MonadUnliftIO m, IsSqlBackend backend) => ReaderT backend m a -> backend -> m a
runSqlPersistM :: IsSqlBackend backend => ReaderT backend (NoLoggingT (ResourceT IO)) a -> backend -> IO a
runSqlPersistMPool :: IsSqlBackend backend => ReaderT backend (NoLoggingT (ResourceT IO)) a -> Pool backend -> IO a

-- | Get a connection from the pool, run the given action, and then return
--   the connection to the pool.
--   
--   Note: This function previously timed out after 2 seconds, but this
--   behavior was buggy and caused more problems than it solved. Since
--   version 2.1.2, it performs no timeout checks.
runSqlPool :: (MonadUnliftIO m, IsSqlBackend backend) => ReaderT backend m a -> Pool backend -> m a

-- | Create a connection and run sql queries within it. This function
--   automatically closes the connection on it's completion.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   {-# LANGUAGE GADTs #-}
--   {-# LANGUAGE ScopedTypeVariables #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   {-# LANGUAGE MultiParamTypeClasses #-}
--   {-# LANGUAGE TypeFamilies#-}
--   {-# LANGUAGE TemplateHaskell#-}
--   {-# LANGUAGE QuasiQuotes#-}
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   
--   import Control.Monad.IO.Class  (liftIO)
--   import Control.Monad.Logger
--   import Conduit
--   import Database.Persist
--   import Database.Sqlite
--   import Database.Persist.Sqlite
--   import Database.Persist.TH
--   
--   share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
--   Person
--     name String
--     age Int Maybe
--     deriving Show
--   |]
--   
--   openConnection :: LogFunc -&gt; IO SqlBackend
--   openConnection logfn = do
--    conn &lt;- open "/home/sibi/test.db"
--    wrapConnection conn logfn
--   
--   main :: IO ()
--   main = do
--     runNoLoggingT $ runResourceT $ withSqlConn openConnection (\backend -&gt;
--                                         flip runSqlConn backend $ do
--                                           runMigration migrateAll
--                                           insert_ $ Person "John doe" $ Just 35
--                                           insert_ $ Person "Divya" $ Just 36
--                                           (pers :: [Entity Person]) &lt;- selectList [] []
--                                           liftIO $ print pers
--                                           return ()
--                                        )
--   </pre>
--   
--   On executing it, you get this output:
--   
--   <pre>
--   Migrating: CREATE TABLE "person"("id" INTEGER PRIMARY KEY,"name" VARCHAR NOT NULL,"age" INTEGER NULL)
--   [Entity {entityKey = PersonKey {unPersonKey = SqlBackendKey {unSqlBackendKey = 1}}, entityVal = Person {personName = "John doe", personAge = Just 35}},Entity {entityKey = PersonKey {unPersonKey = SqlBackendKey {unSqlBackendKey = 2}}, entityVal = Person {personName = "Hema", personAge = Just 36}}]
--   </pre>
withSqlConn :: (MonadUnliftIO m, MonadLogger m, IsSqlBackend backend) => (LogFunc -> IO backend) -> (backend -> m a) -> m a
withSqlPool :: (MonadLogger m, MonadUnliftIO m, IsSqlBackend backend) => (LogFunc -> IO backend) -> Int -> (Pool backend -> m a) -> m a

-- | Useful for running a read query against a backend with unknown
--   capabilities.
readToUnknown :: Monad m => ReaderT SqlReadBackend m a -> ReaderT SqlBackend m a

-- | Useful for running a read query against a backend with read and write
--   capabilities.
readToWrite :: Monad m => ReaderT SqlReadBackend m a -> ReaderT SqlWriteBackend m a

-- | Useful for running a write query against an untagged backend with
--   unknown capabilities.
writeToUnknown :: Monad m => ReaderT SqlWriteBackend m a -> ReaderT SqlBackend m a
entityKeyFields :: EntityDef -> [FieldDef]
entityPrimary :: EntityDef -> Maybe CompositeDef
fromPersistValueText :: PersistValue -> Either Text Text
keyAndEntityFields :: EntityDef -> [FieldDef]
toEmbedEntityDef :: EntityDef -> EmbedEntityDef

-- | A backwards-compatible alias for those that don't care about
--   distinguishing between read and write queries. It signifies the
--   assumption that, by default, a backend can write as well as read.
type PersistStore a = PersistStoreWrite a

-- | A backwards-compatible alias for those that don't care about
--   distinguishing between read and write queries. It signifies the
--   assumption that, by default, a backend can write as well as read.
type PersistUnique a = PersistUniqueWrite a

-- | For combinations of backends and entities that support
--   cascade-deletion. “Cascade-deletion” means that entries that depend on
--   other entries to be deleted will be deleted as well.
class (PersistStoreWrite backend, PersistEntity record, BaseBackend backend ~ PersistEntityBackend record) => DeleteCascade record backend

-- | Perform cascade-deletion of single database entry.
deleteCascade :: (DeleteCascade record backend, MonadIO m) => Key record -> ReaderT backend m ()

-- | Represents a value containing all the configuration options for a
--   specific backend. This abstraction makes it easier to write code that
--   can easily swap backends.
class PersistConfig c where {
    type family PersistConfigBackend c :: Type -> Type -> Type -> Type;
    type family PersistConfigPool c :: Type;
}

-- | Load the config settings from a <a>Value</a>, most likely taken from a
--   YAML config file.
loadConfig :: PersistConfig c => Value -> Parser c

-- | Modify the config settings based on environment variables.
applyEnv :: PersistConfig c => c -> IO c

-- | Create a new connection pool based on the given config settings.
createPoolConfig :: PersistConfig c => c -> IO (PersistConfigPool c)

-- | Run a database action by taking a connection from the pool.
runPool :: (PersistConfig c, MonadUnliftIO m) => c -> PersistConfigBackend c m a -> PersistConfigPool c -> m a
type family BackendSpecificUpdate backend record :: Type

-- | Datatype that represents an entity, with both its <a>Key</a> and its
--   Haskell record representation.
--   
--   When using a SQL-based backend (such as SQLite or PostgreSQL), an
--   <a>Entity</a> may take any number of columns depending on how many
--   fields it has. In order to reconstruct your entity on the Haskell
--   side, <tt>persistent</tt> needs all of your entity columns and in the
--   right order. Note that you don't need to worry about this when using
--   <tt>persistent</tt>'s API since everything is handled correctly behind
--   the scenes.
--   
--   However, if you want to issue a raw SQL command that returns an
--   <a>Entity</a>, then you have to be careful with the column order.
--   While you could use <tt>SELECT Entity.* WHERE ...</tt> and that would
--   work most of the time, there are times when the order of the columns
--   on your database is different from the order that <tt>persistent</tt>
--   expects (for example, if you add a new field in the middle of you
--   entity definition and then use the migration code --
--   <tt>persistent</tt> will expect the column to be in the middle, but
--   your DBMS will put it as the last column). So, instead of using a
--   query like the one above, you may use <a>rawSql</a> (from the
--   <a>Database.Persist.GenericSql</a> module) with its /entity selection
--   placeholder/ (a double question mark <tt>??</tt>). Using
--   <tt>rawSql</tt> the query above must be written as <tt>SELECT ?? WHERE
--   ..</tt>. Then <tt>rawSql</tt> will replace <tt>??</tt> with the list
--   of all columns that we need from your entity in the right order. If
--   your query returns two entities (i.e. <tt>(Entity backend a, Entity
--   backend b)</tt>), then you must you use <tt>SELECT ??, ?? WHERE
--   ...</tt>, and so on.
data Entity record
Entity :: Key record -> record -> Entity record
[entityKey] :: Entity record -> Key record
[entityVal] :: Entity record -> record

-- | Persistent serialized Haskell records to the database. A Database
--   <a>Entity</a> (A row in SQL, a document in MongoDB, etc) corresponds
--   to a <a>Key</a> plus a Haskell record.
--   
--   For every Haskell record type stored in the database there is a
--   corresponding <a>PersistEntity</a> instance. An instance of
--   PersistEntity contains meta-data for the record. PersistEntity also
--   helps abstract over different record types. That way the same query
--   interface can return a <a>PersistEntity</a>, with each query returning
--   different types of Haskell records.
--   
--   Some advanced type system capabilities are used to make this process
--   type-safe. Persistent users usually don't need to understand the class
--   associated data and functions.
class (PersistField Key record, ToJSON Key record, FromJSON Key record, Show Key record, Read Key record, Eq Key record, Ord Key record) => PersistEntity record where {
    
    -- | Persistent allows multiple different backends (databases).
    type family PersistEntityBackend record :: Type;
    
    -- | By default, a backend will automatically generate the key Instead you
    --   can specify a Primary key made up of unique values.
    data family Key record :: Type;
    
    -- | An <a>EntityField</a> is parameterised by the Haskell record it
    --   belongs to and the additional type of that field.
    data family EntityField record a :: Type;
    
    -- | Unique keys besides the <a>Key</a>.
    data family Unique record :: Type;
}

-- | A lower-level key operation.
keyToValues :: PersistEntity record => Key record -> [PersistValue]

-- | A lower-level key operation.
keyFromValues :: PersistEntity record => [PersistValue] -> Either Text (Key record)

-- | A meta-operation to retrieve the <a>Key</a> <a>EntityField</a>.
persistIdField :: PersistEntity record => EntityField record (Key record)

-- | Retrieve the <a>EntityDef</a> meta-data for the record.
entityDef :: (PersistEntity record, Monad m) => m record -> EntityDef

-- | Return meta-data for a given <a>EntityField</a>.
persistFieldDef :: PersistEntity record => EntityField record typ -> FieldDef

-- | A meta-operation to get the database fields of a record.
toPersistFields :: PersistEntity record => record -> [SomePersistField]

-- | A lower-level operation to convert from database values to a Haskell
--   record.
fromPersistValues :: PersistEntity record => [PersistValue] -> Either Text record

-- | A meta operation to retrieve all the <a>Unique</a> keys.
persistUniqueKeys :: PersistEntity record => record -> [Unique record]

-- | A lower level operation.
persistUniqueToFieldNames :: PersistEntity record => Unique record -> [(HaskellName, DBName)]

-- | A lower level operation.
persistUniqueToValues :: PersistEntity record => Unique record -> [PersistValue]

-- | Use a <a>PersistField</a> as a lens.
fieldLens :: PersistEntity record => EntityField record field -> forall (f :: Type -> Type). Functor f => (field -> f field) -> Entity record -> f (Entity record)

-- | This class teaches Persistent how to take a custom type and marshal it
--   to and from a <a>PersistValue</a>, allowing it to be stored in a
--   database.
--   
--   <h4><b>Examples</b></h4>
--   
--   <h5>Simple Newtype</h5>
--   
--   You can use <tt>newtype</tt> to add more type safety/readability to a
--   basis type like <a>ByteString</a>. In these cases, just derive
--   <a>PersistField</a> and <tt>PersistFieldSql</tt>:
--   
--   <pre>
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   
--   newtype HashedPassword = HashedPassword <a>ByteString</a>
--     deriving (Eq, Show, <a>PersistField</a>, PersistFieldSql)
--   </pre>
--   
--   <h5>Smart Constructor Newtype</h5>
--   
--   In this example, we create a <a>PersistField</a> instance for a
--   newtype following the "Smart Constructor" pattern.
--   
--   <pre>
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   import qualified <a>Data.Text</a> as T
--   import qualified <a>Data.Char</a> as C
--   
--   -- | An American Social Security Number
--   newtype SSN = SSN <a>Text</a>
--    deriving (Eq, Show, PersistFieldSql)
--   
--   mkSSN :: <a>Text</a> -&gt; <a>Either</a> <a>Text</a> SSN
--   mkSSN t = if (T.length t == 9) &amp;&amp; (T.all C.isDigit t)
--    then <a>Right</a> $ SSN t
--    else <a>Left</a> $ "Invalid SSN: " &lt;&gt; t
--   
--   instance <a>PersistField</a> SSN where
--     <a>toPersistValue</a> (SSN t) = <a>PersistText</a> t
--     <a>fromPersistValue</a> (<a>PersistText</a> t) = mkSSN t
--     -- Handle cases where the database does not give us PersistText
--     <a>fromPersistValue</a> x = <a>Left</a> $ "File.hs: When trying to deserialize an SSN: expected PersistText, received: " &lt;&gt; T.pack (show x)
--   </pre>
--   
--   Tips:
--   
--   <ul>
--   <li>This file contain dozens of <a>PersistField</a> instances you can
--   look at for examples.</li>
--   <li>Typically custom <a>PersistField</a> instances will only accept a
--   single <a>PersistValue</a> constructor in
--   <a>fromPersistValue</a>.</li>
--   <li>Internal <a>PersistField</a> instances accept a wide variety of
--   <a>PersistValue</a>s to accomodate e.g. storing booleans as integers,
--   booleans or strings.</li>
--   <li>If you're making a custom instance and using a SQL database,
--   you'll also need <tt>PersistFieldSql</tt> to specify the type of the
--   database column.</li>
--   </ul>
class PersistField a
toPersistValue :: PersistField a => a -> PersistValue
fromPersistValue :: PersistField a => PersistValue -> Either Text a
data SomePersistField
[SomePersistField] :: forall a. PersistField a => a -> SomePersistField

-- | Backends supporting conditional read operations.
class (PersistCore backend, PersistStoreRead backend) => PersistQueryRead backend

-- | Get all records matching the given criterion in the specified order.
--   Returns also the identifiers.
selectSourceRes :: (PersistQueryRead backend, PersistRecordBackend record backend, MonadIO m1, MonadIO m2) => [Filter record] -> [SelectOpt record] -> ReaderT backend m1 (Acquire (ConduitM () (Entity record) m2 ()))

-- | Get just the first record for the criterion.
selectFirst :: (PersistQueryRead backend, MonadIO m, PersistRecordBackend record backend) => [Filter record] -> [SelectOpt record] -> ReaderT backend m (Maybe (Entity record))

-- | Get the <a>Key</a>s of all records matching the given criterion.
selectKeysRes :: (PersistQueryRead backend, MonadIO m1, MonadIO m2, PersistRecordBackend record backend) => [Filter record] -> [SelectOpt record] -> ReaderT backend m1 (Acquire (ConduitM () (Key record) m2 ()))

-- | Backends supporting conditional write operations
class (PersistQueryRead backend, PersistStoreWrite backend) => PersistQueryWrite backend

-- | Update individual fields on any record matching the given criterion.
updateWhere :: (PersistQueryWrite backend, MonadIO m, PersistRecordBackend record backend) => [Filter record] -> [Update record] -> ReaderT backend m ()

-- | Delete all records matching the given criterion.
deleteWhere :: (PersistQueryWrite backend, MonadIO m, PersistRecordBackend record backend) => [Filter record] -> ReaderT backend m ()

-- | This class witnesses that two backend are compatible, and that you can
--   convert from the <tt>sub</tt> backend into the <tt>sup</tt> backend.
--   This is similar to the <a>HasPersistBackend</a> and
--   <a>IsPersistBackend</a> classes, but where you don't want to fix the
--   type associated with the <a>PersistEntityBackend</a> of a record.
--   
--   Generally speaking, where you might have:
--   
--   <pre>
--   foo ::
--     ( <a>PersistEntity</a> record
--     , <tt>PeristEntityBackend</tt> record ~ <a>BaseBackend</a> backend
--     , <tt>IsSqlBackend</tt> backend
--     )
--   </pre>
--   
--   this can be replaced with:
--   
--   <pre>
--   foo ::
--     ( <a>PersistEntity</a> record,
--     , <a>PersistEntityBackend</a> record ~ backend
--     , <a>BackendCompatible</a> <tt>SqlBackend</tt> backend
--     )
--   </pre>
--   
--   This works for <tt>SqlReadBackend</tt> because of the <tt>instance
--   <a>BackendCompatible</a> <tt>SqlBackend</tt>
--   <tt>SqlReadBackend</tt></tt>, without needing to go through the
--   <a>BaseBackend</a> type family.
--   
--   Likewise, functions that are currently hardcoded to use
--   <tt>SqlBackend</tt> can be generalized:
--   
--   <pre>
--   -- before:
--   asdf :: <a>ReaderT</a> <tt>SqlBackend</tt> m ()
--   asdf = pure ()
--   
--   -- after:
--   asdf' :: <a>BackendCompatible</a> SqlBackend backend =&gt; ReaderT backend m ()
--   asdf' = withReaderT <a>projectBackend</a> asdf
--   </pre>
class BackendCompatible sup sub
projectBackend :: BackendCompatible sup sub => sub -> sup
data family BackendKey backend :: Type

-- | Class which allows the plucking of a <tt>BaseBackend backend</tt> from
--   some larger type. For example, <tt> instance HasPersistBackend
--   (SqlReadBackend, Int) where type BaseBackend (SqlReadBackend, Int) =
--   SqlBackend persistBackend = unSqlReadBackend . fst </tt>
class HasPersistBackend backend where {
    type family BaseBackend backend :: Type;
}
persistBackend :: HasPersistBackend backend => backend -> BaseBackend backend

-- | Class which witnesses that <tt>backend</tt> is essentially the same as
--   <tt>BaseBackend backend</tt>. That is, they're isomorphic and
--   <tt>backend</tt> is just some wrapper over <tt>BaseBackend
--   backend</tt>.
class HasPersistBackend backend => IsPersistBackend backend
class PersistCore backend where {
    data family BackendKey backend :: Type;
}

-- | A convenient alias for common type signatures
type PersistRecordBackend record backend = (PersistEntity record, PersistEntityBackend record ~ BaseBackend backend)
class (Show BackendKey backend, Read BackendKey backend, Eq BackendKey backend, Ord BackendKey backend, PersistCore backend, PersistField BackendKey backend, ToJSON BackendKey backend, FromJSON BackendKey backend) => PersistStoreRead backend

-- | Get a record by identifier, if available.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   getSpj :: MonadIO m =&gt; ReaderT SqlBackend m (Maybe User)
--   getSpj = get spjId
--   </pre>
--   
--   <pre>
--   mspj &lt;- getSpj
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will get this:
--   
--   <pre>
--   +------+-----+
--   | name | age |
--   +------+-----+
--   | SPJ  |  40 |
--   +------+-----+
--   </pre>
get :: (PersistStoreRead backend, MonadIO m, PersistRecordBackend record backend) => Key record -> ReaderT backend m (Maybe record)

-- | Get many records by their respective identifiers, if available.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>:
--   
--   <pre>
--   getUsers :: MonadIO m =&gt; ReaderT SqlBackend m (Map (Key User) User)
--   getUsers = getMany allkeys
--   </pre>
--   
--   <pre>
--   musers &lt;- getUsers
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will get these
--   records:
--   
--   <pre>
--   +----+-------+-----+
--   | id | name  | age |
--   +----+-------+-----+
--   |  1 | SPJ   |  40 |
--   +----+-------+-----+
--   |  2 | Simon |  41 |
--   +----+-------+-----+
--   </pre>
getMany :: (PersistStoreRead backend, MonadIO m, PersistRecordBackend record backend) => [Key record] -> ReaderT backend m (Map (Key record) record)
class (Show BackendKey backend, Read BackendKey backend, Eq BackendKey backend, Ord BackendKey backend, PersistStoreRead backend, PersistField BackendKey backend, ToJSON BackendKey backend, FromJSON BackendKey backend) => PersistStoreWrite backend

-- | Create a new record in the database, returning an automatically
--   created key (in SQL an auto-increment id).
--   
--   <h3><b>Example usage</b></h3>
--   
--   Using <a>schema-1</a> and <a>dataset-1</a>, let's insert a new user
--   <tt>John</tt>.
--   
--   <pre>
--   insertJohn :: MonadIO m =&gt; ReaderT SqlBackend m (Key User)
--   insertJohn = insert $ User "John" 30
--   </pre>
--   
--   <pre>
--   johnId &lt;- insertJohn
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |John  |30   |
--   +-----+------+-----+
--   </pre>
insert :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => record -> ReaderT backend m (Key record)

-- | Same as <a>insert</a>, but doesn't return a <tt>Key</tt>.
--   
--   <h3><b>Example usage</b></h3>
--   
--   with <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   insertJohn :: MonadIO m =&gt; ReaderT SqlBackend m (Key User)
--   insertJohn = insert_ $ User "John" 30
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |John  |30   |
--   +-----+------+-----+
--   </pre>
insert_ :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => record -> ReaderT backend m ()

-- | Create multiple records in the database and return their <a>Key</a>s.
--   
--   If you don't need the inserted <a>Key</a>s, use <a>insertMany_</a>.
--   
--   The MongoDB and PostgreSQL backends insert all records and retrieve
--   their keys in one database query.
--   
--   The SQLite and MySQL backends use the slow, default implementation of
--   <tt>mapM insert</tt>.
--   
--   <h3><b>Example usage</b></h3>
--   
--   with <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   insertUsers :: MonadIO m =&gt; ReaderT SqlBackend m [Key User]
--   insertUsers = insertMany [User "John" 30, User "Nick" 32, User "Jane" 20]
--   </pre>
--   
--   <pre>
--   userIds &lt;- insertUsers
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |John  |30   |
--   +-----+------+-----+
--   |4    |Nick  |32   |
--   +-----+------+-----+
--   |5    |Jane  |20   |
--   +-----+------+-----+
--   </pre>
insertMany :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => [record] -> ReaderT backend m [Key record]

-- | Same as <a>insertMany</a>, but doesn't return any <a>Key</a>s.
--   
--   The MongoDB, PostgreSQL, SQLite and MySQL backends insert all records
--   in one database query.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   insertUsers_ :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   insertUsers_ = insertMany_ [User "John" 30, User "Nick" 32, User "Jane" 20]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |John  |30   |
--   +-----+------+-----+
--   |4    |Nick  |32   |
--   +-----+------+-----+
--   |5    |Jane  |20   |
--   +-----+------+-----+
--   </pre>
insertMany_ :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => [record] -> ReaderT backend m ()

-- | Same as <a>insertMany_</a>, but takes an <a>Entity</a> instead of just
--   a record.
--   
--   Useful when migrating data from one entity to another and want to
--   preserve ids.
--   
--   The MongoDB, PostgreSQL, SQLite and MySQL backends insert all records
--   in one database query.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   insertUserEntityMany :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   insertUserEntityMany = insertEntityMany [SnakeEntity, EvaEntity]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |Snake |38   |
--   +-----+------+-----+
--   |4    |Eva   |38   |
--   +-----+------+-----+
--   </pre>
insertEntityMany :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => [Entity record] -> ReaderT backend m ()

-- | Create a new record in the database using the given key.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   insertAliceKey :: MonadIO m =&gt; Key User -&gt; ReaderT SqlBackend m ()
--   insertAliceKey key = insertKey key $ User "Alice" 20
--   </pre>
--   
--   <pre>
--   insertAliceKey $ UserKey {unUserKey = SqlBackendKey {unSqlBackendKey = 3}}
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |Alice |20   |
--   +-----+------+-----+
--   </pre>
insertKey :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> record -> ReaderT backend m ()

-- | Put the record in the database with the given key. Unlike
--   <a>replace</a>, if a record with the given key does not exist then a
--   new record will be inserted.
--   
--   <h3><b>Example usage</b></h3>
--   
--   We try to explain <tt>upsertBy</tt> using <a>schema-1</a> and
--   <a>dataset-1</a>.
--   
--   First, we insert Philip to <a>dataset-1</a>.
--   
--   <pre>
--   insertPhilip :: MonadIO m =&gt; ReaderT SqlBackend m (Key User)
--   insertPhilip = insert $ User "Philip" 42
--   </pre>
--   
--   <pre>
--   philipId &lt;- insertPhilip
--   </pre>
--   
--   This query will produce:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |Philip|42   |
--   +-----+------+-----+
--   </pre>
--   
--   <pre>
--   repsertHaskell :: MonadIO m =&gt; Key record -&gt; ReaderT SqlBackend m ()
--   repsertHaskell id = repsert id $ User "Haskell" 81
--   </pre>
--   
--   <pre>
--   repsertHaskell philipId
--   </pre>
--   
--   This query will replace Philip's record with Haskell's one:
--   
--   <pre>
--   +-----+-----------------+--------+
--   |id   |name             |age     |
--   +-----+-----------------+--------+
--   |1    |SPJ              |40      |
--   +-----+-----------------+--------+
--   |2    |Simon            |41      |
--   +-----+-----------------+--------+
--   |3    |Philip -&gt; Haskell|42 -&gt; 81|
--   +-----+-----------------+--------+
--   </pre>
--   
--   <a>repsert</a> inserts the given record if the key doesn't exist.
--   
--   <pre>
--   repsertXToUnknown :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   repsertXToUnknown = repsert unknownId $ User "X" 999
--   </pre>
--   
--   For example, applying the above query to <a>dataset-1</a> will produce
--   this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |X     |999  |
--   +-----+------+-----+
--   </pre>
repsert :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> record -> ReaderT backend m ()

-- | Put many entities into the database.
--   
--   Batch version of <a>repsert</a> for SQL backends.
--   
--   Useful when migrating data from one entity to another and want to
--   preserve ids.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   repsertManyUsers :: MonadIO m =&gt;ReaderT SqlBackend m ()
--   repsertManyusers = repsertMany [(simonId, User "Philip" 20), (unknownId999, User "Mr. X" 999)]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+----------------+---------+
--   |id   |name            |age      |
--   +-----+----------------+---------+
--   |1    |SPJ             |40       |
--   +-----+----------------+---------+
--   |2    |Simon -&gt; Philip |41 -&gt; 20 |
--   +-----+----------------+---------+
--   |999  |Mr. X           |999      |
--   +-----+----------------+---------+
--   </pre>
repsertMany :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => [(Key record, record)] -> ReaderT backend m ()

-- | Replace the record in the database with the given key. Note that the
--   result is undefined if such record does not exist, so you must use
--   <a>insertKey</a> or <a>repsert</a> in these cases.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1 schama-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   replaceSpj :: MonadIO m =&gt; User -&gt; ReaderT SqlBackend m ()
--   replaceSpj record = replace spjId record
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |Mike  |45   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   </pre>
replace :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> record -> ReaderT backend m ()

-- | Update individual fields on a specific record, and retrieve the
--   updated value from the database.
--   
--   Note that this function will throw an exception if the given key is
--   not found in the database.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   updateGetSpj :: MonadIO m =&gt; [Update User] -&gt; ReaderT SqlBackend m User
--   updateGetSpj updates = updateGet spjId updates
--   </pre>
--   
--   <pre>
--   spj &lt;- updateGetSpj [UserAge +=. 100]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |140  |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   </pre>
updateGet :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> [Update record] -> ReaderT backend m record

-- | <a>ToBackendKey</a> converts a <a>PersistEntity</a> <a>Key</a> into a
--   <a>BackendKey</a> This can be used by each backend to convert between
--   a <a>Key</a> and a plain Haskell type. For Sql, that is done with
--   <tt>toSqlKey</tt> and <tt>fromSqlKey</tt>.
--   
--   By default, a <a>PersistEntity</a> uses the default <a>BackendKey</a>
--   for its Key and is an instance of ToBackendKey
--   
--   A <a>Key</a> that instead uses a custom type will not be an instance
--   of <a>ToBackendKey</a>.
class (PersistEntity record, PersistEntityBackend record ~ backend, PersistCore backend) => ToBackendKey backend record
toBackendKey :: ToBackendKey backend record => Key record -> BackendKey backend
fromBackendKey :: ToBackendKey backend record => BackendKey backend -> Key record

-- | Queries against <a>Unique</a> keys (other than the id <a>Key</a>).
--   
--   Please read the general Persistent documentation to learn how to
--   create <a>Unique</a> keys.
--   
--   Using this with an Entity without a Unique key leads to undefined
--   behavior. A few of these functions require a <i>single</i>
--   <a>Unique</a>, so using an Entity with multiple <a>Unique</a>s is also
--   undefined. In these cases persistent's goal is to throw an exception
--   as soon as possible, but persistent is still transitioning to that.
--   
--   SQL backends automatically create uniqueness constraints, but for
--   MongoDB you must manually place a unique index on a field to have a
--   uniqueness constraint.
class (PersistCore backend, PersistStoreRead backend) => PersistUniqueRead backend

-- | Get a record by unique key, if available. Returns also the identifier.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>:
--   
--   <pre>
--   getBySpjName :: MonadIO m  =&gt; ReaderT SqlBackend m (Maybe (Entity User))
--   getBySpjName = getBy $ UniqueUserName "SPJ"
--   </pre>
--   
--   <pre>
--   mSpjEnt &lt;- getBySpjName
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will get this
--   entity:
--   
--   <pre>
--   +----+------+-----+
--   | id | name | age |
--   +----+------+-----+
--   |  1 | SPJ  |  40 |
--   +----+------+-----+
--   </pre>
getBy :: (PersistUniqueRead backend, MonadIO m, PersistRecordBackend record backend) => Unique record -> ReaderT backend m (Maybe (Entity record))

-- | Some functions in this module (<a>insertUnique</a>, <a>insertBy</a>,
--   and <a>replaceUnique</a>) first query the unique indexes to check for
--   conflicts. You could instead optimistically attempt to perform the
--   operation (e.g. <a>replace</a> instead of <a>replaceUnique</a>).
--   However,
--   
--   <ul>
--   <li>there is some fragility to trying to catch the correct exception
--   and determing the column of failure;</li>
--   <li>an exception will automatically abort the current SQL
--   transaction.</li>
--   </ul>
class (PersistUniqueRead backend, PersistStoreWrite backend) => PersistUniqueWrite backend

-- | Delete a specific record by unique key. Does nothing if no record
--   matches.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>,
--   
--   <pre>
--   deleteBySpjName :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   deleteBySpjName = deleteBy UniqueUserName "SPJ"
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   </pre>
deleteBy :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => Unique record -> ReaderT backend m ()

-- | Like <a>insert</a>, but returns <a>Nothing</a> when the record
--   couldn't be inserted because of a uniqueness constraint.
--   
--   <h3><b>Example usage</b></h3>
--   
--   With <a>schema-1</a> and <a>dataset-1</a>, we try to insert the
--   following two records:
--   
--   <pre>
--   linusId &lt;- insertUnique $ User "Linus" 48
--   spjId   &lt;- insertUnique $ User "SPJ" 90
--   </pre>
--   
--   <pre>
--   +-----+------+-----+
--   |id   |name  |age  |
--   +-----+------+-----+
--   |1    |SPJ   |40   |
--   +-----+------+-----+
--   |2    |Simon |41   |
--   +-----+------+-----+
--   |3    |Linus |48   |
--   +-----+------+-----+
--   </pre>
--   
--   Linus's record was inserted to <a>dataset-1</a>, while SPJ wasn't
--   because SPJ already exists in <a>dataset-1</a>.
insertUnique :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => record -> ReaderT backend m (Maybe (Key record))

-- | Update based on a uniqueness constraint or insert:
--   
--   <ul>
--   <li>insert the new record if it does not exist;</li>
--   <li>If the record exists (matched via it's uniqueness constraint),
--   then update the existing record with the parameters which is passed on
--   as list to the function.</li>
--   </ul>
--   
--   Throws an exception if there is more than 1 uniqueness constraint.
--   
--   <h3><b>Example usage</b></h3>
--   
--   First, we try to explain <a>upsert</a> using <a>schema-1</a> and
--   <a>dataset-1</a>.
--   
--   <pre>
--   upsertSpj :: MonadIO m =&gt; [Update User] -&gt; ReaderT SqlBackend m (Maybe (Entity User))
--   upsertSpj updates = upsert (User "SPJ" 999) upadtes
--   </pre>
--   
--   <pre>
--   mSpjEnt &lt;- upsertSpj [UserAge +=. 15]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+--------+
--   |id   |name |age     |
--   +-----+-----+--------+
--   |1    |SPJ  |40 -&gt; 55|
--   +-----+-----+--------+
--   |2    |Simon|41      |
--   +-----+-----+--------+
--   </pre>
--   
--   <pre>
--   upsertX :: MonadIO m =&gt; [Update User] -&gt; ReaderT SqlBackend m (Maybe (Entity User))
--   upsertX updates = upsert (User "X" 999) upadtes
--   </pre>
--   
--   <pre>
--   mXEnt &lt;- upsertX [UserAge +=. 15]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+--------+
--   |id   |name |age     |
--   +-----+-----+--------+
--   |1    |SPJ  |40      |
--   +-----+-----+--------+
--   |2    |Simon|41      |
--   +-----+-----+--------+
--   |3    |X    |999     |
--   +-----+-----+--------+
--   </pre>
--   
--   Next, what if the schema has two uniqueness constraints? Let's check
--   it out using <a>schema-2</a>:
--   
--   <pre>
--   mSpjEnt &lt;- upsertSpj [UserAge +=. 15]
--   </pre>
--   
--   Then, it throws an error message something like "Expected only one
--   unique key, got"
upsert :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => record -> [Update record] -> ReaderT backend m (Entity record)

-- | Update based on a given uniqueness constraint or insert:
--   
--   <ul>
--   <li>insert the new record if it does not exist;</li>
--   <li>update the existing record that matches the given uniqueness
--   constraint.</li>
--   </ul>
--   
--   <h3><b>Example usage</b></h3>
--   
--   We try to explain <a>upsertBy</a> using <a>schema-2</a> and
--   <a>dataset-1</a>.
--   
--   <pre>
--   upsertBySpjName :: MonadIO m =&gt; User -&gt; [Update User] -&gt; ReaderT SqlBackend m (Entity User)
--   upsertBySpjName record updates = upsertBy (UniqueUserName "SPJ") record updates
--   </pre>
--   
--   <pre>
--   mSpjEnt &lt;- upsertBySpjName (Person "X" 999) [PersonAge += .15]
--   </pre>
--   
--   The above query will alter <a>dataset-1</a> to:
--   
--   <pre>
--   +-----+-----+--------+
--   |id   |name |age     |
--   +-----+-----+--------+
--   |1    |SPJ  |40 -&gt; 55|
--   +-----+-----+--------+
--   |2    |Simon|41      |
--   +-----+-----+--------+
--   </pre>
--   
--   <pre>
--   upsertBySimonAge :: MonadIO m =&gt; User -&gt; [Update User] -&gt; ReaderT SqlBackend m (Entity User)
--   upsertBySimonAge record updates = upsertBy (UniqueUserName "SPJ") record updates
--   </pre>
--   
--   <pre>
--   mPhilipEnt &lt;- upsertBySimonAge (User "X" 999) [UserName =. "Philip"]
--   </pre>
--   
--   The above query will alter <a>dataset-1</a> to:
--   
--   <pre>
--   +----+-----------------+-----+
--   | id |      name       | age |
--   +----+-----------------+-----+
--   |  1 | SPJ             |  40 |
--   +----+-----------------+-----+
--   |  2 | Simon -&gt; Philip |  41 |
--   +----+-----------------+-----+
--   </pre>
--   
--   <pre>
--   upsertByUnknownName :: MonadIO m =&gt; User -&gt; [Update User] -&gt; ReaderT SqlBackend m (Entity User)
--   upsertByUnknownName record updates = upsertBy (UniqueUserName "Unknown") record updates
--   </pre>
--   
--   <pre>
--   mXEnt &lt;- upsertByUnknownName (User "X" 999) [UserAge +=. 15]
--   </pre>
--   
--   This query will alter <a>dataset-1</a> to:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |1    |SPJ  |40   |
--   +-----+-----+-----+
--   |2    |Simon|41   |
--   +-----+-----+-----+
--   |3    |X    |999  |
--   +-----+-----+-----+
--   </pre>
upsertBy :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => Unique record -> record -> [Update record] -> ReaderT backend m (Entity record)

-- | Put many records into db
--   
--   <ul>
--   <li>insert new records that do not exist (or violate any unique
--   constraints)</li>
--   <li>replace existing records (matching any unique constraint) @since
--   2.8.1</li>
--   </ul>
putMany :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => [record] -> ReaderT backend m ()

-- | Tells Persistent what database column type should be used to store a
--   Haskell type.
--   
--   <h4><b>Examples</b></h4>
--   
--   <h5>Simple Boolean Alternative</h5>
--   
--   <pre>
--   data Switch = On | Off
--     deriving (Show, Eq)
--   
--   instance <a>PersistField</a> Switch where
--     <a>toPersistValue</a> s = case s of
--       On -&gt; <a>PersistBool</a> True
--       Off -&gt; <a>PersistBool</a> False
--     <a>fromPersistValue</a> (<a>PersistBool</a> b) = if b then <a>Right</a> On else <a>Right</a> Off
--     <a>fromPersistValue</a> x = Left $ "File.hs: When trying to deserialize a Switch: expected PersistBool, received: " &lt;&gt; T.pack (show x)
--   
--   instance <a>PersistFieldSql</a> Switch where
--     <a>sqlType</a> _ = <a>SqlBool</a>
--   </pre>
--   
--   <h5>Non-Standard Database Types</h5>
--   
--   If your database supports non-standard types, such as Postgres'
--   <tt>uuid</tt>, you can use <a>SqlOther</a> to use them:
--   
--   <pre>
--   import qualified Data.UUID as UUID
--   instance <a>PersistField</a> UUID where
--     <a>toPersistValue</a> = <a>PersistDbSpecific</a> . toASCIIBytes
--     <a>fromPersistValue</a> (<a>PersistDbSpecific</a> uuid) =
--       case fromASCIIBytes uuid of
--         <a>Nothing</a> -&gt; <a>Left</a> $ "Model/CustomTypes.hs: Failed to deserialize a UUID; received: " &lt;&gt; T.pack (show uuid)
--         <a>Just</a> uuid' -&gt; <a>Right</a> uuid'
--     <a>fromPersistValue</a> x = Left $ "File.hs: When trying to deserialize a UUID: expected PersistDbSpecific, received: "-- &gt;  &lt;&gt; T.pack (show x)
--   
--   instance <a>PersistFieldSql</a> UUID where
--     <a>sqlType</a> _ = <a>SqlOther</a> "uuid"
--   </pre>
--   
--   <h5>User Created Database Types</h5>
--   
--   Similarly, some databases support creating custom types, e.g.
--   Postgres' <a>DOMAIN</a> and <a>ENUM</a> features. You can use
--   <a>SqlOther</a> to specify a custom type:
--   
--   <pre>
--   CREATE DOMAIN ssn AS text
--         CHECK ( value ~ '^[0-9]{9}$');
--   </pre>
--   
--   <pre>
--   instance <tt>PersistFieldSQL</tt> SSN where
--     <a>sqlType</a> _ = <a>SqlOther</a> "ssn"
--   </pre>
--   
--   <pre>
--   CREATE TYPE rainbow_color AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet');
--   </pre>
--   
--   <pre>
--   instance <tt>PersistFieldSQL</tt> RainbowColor where
--     <a>sqlType</a> _ = <a>SqlOther</a> "rainbow_color"
--   </pre>
class PersistField a => PersistFieldSql a
sqlType :: PersistFieldSql a => Proxy a -> SqlType

-- | Class for data types that may be retrived from a <tt>rawSql</tt>
--   query.
class RawSql a

-- | Number of columns that this data type needs and the list of
--   substitutions for <tt>SELECT</tt> placeholders <tt>??</tt>.
rawSqlCols :: RawSql a => (DBName -> Text) -> a -> (Int, [Text])

-- | A string telling the user why the column count is what it is.
rawSqlColCountReason :: RawSql a => a -> String

-- | Transform a row of the result into the data type.
rawSqlProcessRow :: RawSql a => [PersistValue] -> Either Text a
type CautiousMigration = [(Bool, Sql)]
data Column
Column :: !DBName -> !Bool -> !SqlType -> !Maybe Text -> !Maybe DBName -> !Maybe Integer -> !Maybe (DBName, DBName) -> Column
[cName] :: Column -> !DBName
[cNull] :: Column -> !Bool
[cSqlType] :: Column -> !SqlType
[cDefault] :: Column -> !Maybe Text
[cDefaultConstraintName] :: Column -> !Maybe DBName
[cMaxLen] :: Column -> !Maybe Integer
[cReference] :: Column -> !Maybe (DBName, DBName)
type ConnectionPool = Pool SqlBackend

-- | A <a>Migration</a> is a four level monad stack consisting of:
--   
--   <ul>
--   <li><tt><a>WriterT</a> [<a>Text</a>]</tt> representing a log of errors
--   in the migrations.</li>
--   <li><tt><a>WriterT</a> <a>CautiousMigration</a></tt> representing a
--   list of migrations to run, along with whether or not they are
--   safe.</li>
--   <li><tt><a>ReaderT</a> <a>SqlBackend</a></tt>, aka the
--   <a>SqlPersistT</a> transformer for database interop.</li>
--   <li><tt><a>IO</a></tt> for arbitrary IO.</li>
--   </ul>
type Migration = WriterT [Text] WriterT CautiousMigration ReaderT SqlBackend IO ()
data PersistentSqlException
StatementAlreadyFinalized :: Text -> PersistentSqlException
Couldn'tGetSQLConnection :: PersistentSqlException

-- | A single column (see <tt>rawSql</tt>). Any <tt>PersistField</tt> may
--   be used here, including <a>PersistValue</a> (which does not do any
--   processing).
newtype Single a
Single :: a -> Single a
[unSingle] :: Single a -> a
type Sql = Text
type SqlPersistM = SqlPersistT NoLoggingT ResourceT IO
type SqlPersistT = ReaderT SqlBackend
data InsertSqlResult
ISRSingle :: Text -> InsertSqlResult
ISRInsertGet :: Text -> Text -> InsertSqlResult
ISRManyKeys :: Text -> [PersistValue] -> InsertSqlResult

-- | A backend which is a wrapper around <tt>SqlBackend</tt>.
type IsSqlBackend backend = (IsPersistBackend backend, BaseBackend backend ~ SqlBackend)
type LogFunc = Loc -> LogSource -> LogLevel -> LogStr -> IO ()
data SqlBackend
SqlBackend :: (Text -> IO Statement) -> (EntityDef -> [PersistValue] -> InsertSqlResult) -> Maybe (EntityDef -> [[PersistValue]] -> InsertSqlResult) -> Maybe (EntityDef -> Text -> Text) -> Maybe (EntityDef -> Int -> Text) -> IORef (Map Text Statement) -> IO () -> ([EntityDef] -> (Text -> IO Statement) -> EntityDef -> IO (Either [Text] [(Bool, Text)])) -> ((Text -> IO Statement) -> Maybe IsolationLevel -> IO ()) -> ((Text -> IO Statement) -> IO ()) -> ((Text -> IO Statement) -> IO ()) -> (DBName -> Text) -> Text -> Text -> ((Int, Int) -> Bool -> Text -> Text) -> LogFunc -> Maybe Int -> Maybe (EntityDef -> Int -> Text) -> SqlBackend
[connPrepare] :: SqlBackend -> Text -> IO Statement

-- | table name, column names, id name, either 1 or 2 statements to run
[connInsertSql] :: SqlBackend -> EntityDef -> [PersistValue] -> InsertSqlResult

-- | SQL for inserting many rows and returning their primary keys, for
--   backends that support this functioanlity. If <a>Nothing</a>, rows will
--   be inserted one-at-a-time using <a>connInsertSql</a>.
[connInsertManySql] :: SqlBackend -> Maybe (EntityDef -> [[PersistValue]] -> InsertSqlResult)

-- | Some databases support performing UPSERT _and_ RETURN entity in a
--   single call.
--   
--   This field when set will be used to generate the UPSERT+RETURN sql
--   given * an entity definition * updates to be run on unique key(s)
--   collision
--   
--   When left as <a>Nothing</a>, we find the unique key from entity def
--   before * trying to fetch an entity by said key * perform an update
--   when result found, else issue an insert * return new entity from db
[connUpsertSql] :: SqlBackend -> Maybe (EntityDef -> Text -> Text)

-- | Some databases support performing bulk UPSERT, specifically "insert or
--   replace many records" in a single call.
--   
--   This field when set, given * an entity definition * number of records
--   to be inserted should produce a PUT MANY sql with placeholders for
--   records
--   
--   When left as <a>Nothing</a>, we default to using
--   <tt>defaultPutMany</tt>.
[connPutManySql] :: SqlBackend -> Maybe (EntityDef -> Int -> Text)
[connStmtMap] :: SqlBackend -> IORef (Map Text Statement)
[connClose] :: SqlBackend -> IO ()
[connMigrateSql] :: SqlBackend -> [EntityDef] -> (Text -> IO Statement) -> EntityDef -> IO (Either [Text] [(Bool, Text)])
[connBegin] :: SqlBackend -> (Text -> IO Statement) -> Maybe IsolationLevel -> IO ()
[connCommit] :: SqlBackend -> (Text -> IO Statement) -> IO ()
[connRollback] :: SqlBackend -> (Text -> IO Statement) -> IO ()
[connEscapeName] :: SqlBackend -> DBName -> Text
[connNoLimit] :: SqlBackend -> Text
[connRDBMS] :: SqlBackend -> Text
[connLimitOffset] :: SqlBackend -> (Int, Int) -> Bool -> Text -> Text
[connLogFunc] :: SqlBackend -> LogFunc

-- | Some databases (probably only Sqlite) have a limit on how many
--   question-mark parameters may be used in a statement
[connMaxParams] :: SqlBackend -> Maybe Int

-- | Some databases support performing bulk an atomic+bulk INSERT where
--   constraint conflicting entities can replace existing entities.
--   
--   This field when set, given * an entity definition * number of records
--   to be inserted should produce a INSERT sql with placeholders for
--   primary+record fields
--   
--   When left as <a>Nothing</a>, we default to using
--   <tt>defaultRepsertMany</tt>.
[connRepsertManySql] :: SqlBackend -> Maybe (EntityDef -> Int -> Text)

-- | A constraint synonym which witnesses that a backend is SQL and can run
--   read queries.
type SqlBackendCanRead backend = (BackendCompatible SqlBackend backend, PersistQueryRead backend, PersistStoreRead backend, PersistUniqueRead backend)

-- | A constraint synonym which witnesses that a backend is SQL and can run
--   read and write queries.
type SqlBackendCanWrite backend = (SqlBackendCanRead backend, PersistQueryWrite backend, PersistStoreWrite backend, PersistUniqueWrite backend)

-- | An SQL backend which can only handle read queries
data SqlReadBackend

-- | Like <tt>SqlPersistT</tt> but compatible with any SQL backend which
--   can handle read queries.
type SqlReadT (m :: Type -> Type) a = forall backend. SqlBackendCanRead backend => ReaderT backend m a

-- | An SQL backend which can handle read or write queries
data SqlWriteBackend

-- | Like <tt>SqlPersistT</tt> but compatible with any SQL backend which
--   can handle read and write queries.
type SqlWriteT (m :: Type -> Type) a = forall backend. SqlBackendCanWrite backend => ReaderT backend m a
data Statement
Statement :: IO () -> IO () -> ([PersistValue] -> IO Int64) -> (forall (m :: Type -> Type). MonadIO m => [PersistValue] -> Acquire (ConduitM () [PersistValue] m ())) -> Statement
[stmtFinalize] :: Statement -> IO ()
[stmtReset] :: Statement -> IO ()
[stmtExecute] :: Statement -> [PersistValue] -> IO Int64
[stmtQuery] :: Statement -> forall (m :: Type -> Type). MonadIO m => [PersistValue] -> Acquire (ConduitM () [PersistValue] m ())
type Attr = Text

-- | A <a>Checkmark</a> should be used as a field type whenever a
--   uniqueness constraint should guarantee that a certain kind of record
--   may appear at most once, but other kinds of records may appear any
--   number of times.
--   
--   <i>NOTE:</i> You need to mark any <tt>Checkmark</tt> fields as
--   <tt>nullable</tt> (see the following example).
--   
--   For example, suppose there's a <tt>Location</tt> entity that
--   represents where a user has lived:
--   
--   <pre>
--   Location
--       user    UserId
--       name    Text
--       current Checkmark nullable
--   
--       UniqueLocation user current
--   </pre>
--   
--   The <tt>UniqueLocation</tt> constraint allows any number of
--   <a>Inactive</a> <tt>Location</tt>s to be <tt>current</tt>. However,
--   there may be at most one <tt>current</tt> <tt>Location</tt> per user
--   (i.e., either zero or one per user).
--   
--   This data type works because of the way that SQL treats
--   <tt>NULL</tt>able fields within uniqueness constraints. The SQL
--   standard says that <tt>NULL</tt> values should be considered
--   different, so we represent <a>Inactive</a> as SQL <tt>NULL</tt>, thus
--   allowing any number of <a>Inactive</a> records. On the other hand, we
--   represent <a>Active</a> as <tt>TRUE</tt>, so the uniqueness constraint
--   will disallow more than one <a>Active</a> record.
--   
--   <i>Note:</i> There may be DBMSs that do not respect the SQL standard's
--   treatment of <tt>NULL</tt> values on uniqueness constraints, please
--   check if this data type works before relying on it.
--   
--   The SQL <tt>BOOLEAN</tt> type is used because it's the smallest data
--   type available. Note that we never use <tt>FALSE</tt>, just
--   <tt>TRUE</tt> and <tt>NULL</tt>. Provides the same behavior <tt>Maybe
--   ()</tt> would if <tt>()</tt> was a valid <tt>PersistField</tt>.
data Checkmark

-- | When used on a uniqueness constraint, there may be at most one
--   <a>Active</a> record.
Active :: Checkmark

-- | When used on a uniqueness constraint, there may be any number of
--   <a>Inactive</a> records.
Inactive :: Checkmark
data CompositeDef
CompositeDef :: ![FieldDef] -> ![Attr] -> CompositeDef
[compositeFields] :: CompositeDef -> ![FieldDef]
[compositeAttrs] :: CompositeDef -> ![Attr]
newtype DBName
DBName :: Text -> DBName
[unDBName] :: DBName -> Text

-- | An EmbedEntityDef is the same as an EntityDef But it is only used for
--   fieldReference so it only has data needed for embedding
data EmbedEntityDef
EmbedEntityDef :: !HaskellName -> ![EmbedFieldDef] -> EmbedEntityDef
[embeddedHaskell] :: EmbedEntityDef -> !HaskellName
[embeddedFields] :: EmbedEntityDef -> ![EmbedFieldDef]

-- | An EmbedFieldDef is the same as a FieldDef But it is only used for
--   embeddedFields so it only has data needed for embedding
data EmbedFieldDef
EmbedFieldDef :: !DBName -> Maybe EmbedEntityDef -> Maybe HaskellName -> EmbedFieldDef
[emFieldDB] :: EmbedFieldDef -> !DBName
[emFieldEmbed] :: EmbedFieldDef -> Maybe EmbedEntityDef

-- | <a>emFieldEmbed</a> can create a cycle (issue #311) when a cycle is
--   detected, <a>emFieldEmbed</a> will be Nothing and <a>emFieldCycle</a>
--   will be Just
[emFieldCycle] :: EmbedFieldDef -> Maybe HaskellName
data EntityDef
EntityDef :: !HaskellName -> !DBName -> !FieldDef -> ![Attr] -> ![FieldDef] -> ![UniqueDef] -> ![ForeignDef] -> ![Text] -> !Map Text [ExtraLine] -> !Bool -> EntityDef
[entityHaskell] :: EntityDef -> !HaskellName
[entityDB] :: EntityDef -> !DBName
[entityId] :: EntityDef -> !FieldDef
[entityAttrs] :: EntityDef -> ![Attr]
[entityFields] :: EntityDef -> ![FieldDef]
[entityUniques] :: EntityDef -> ![UniqueDef]
[entityForeigns] :: EntityDef -> ![ForeignDef]
[entityDerives] :: EntityDef -> ![Text]
[entityExtra] :: EntityDef -> !Map Text [ExtraLine]
[entitySum] :: EntityDef -> !Bool
type ExtraLine = [Text]
data FieldDef
FieldDef :: !HaskellName -> !DBName -> !FieldType -> !SqlType -> ![Attr] -> !Bool -> !ReferenceDef -> FieldDef

-- | name of the field
[fieldHaskell] :: FieldDef -> !HaskellName
[fieldDB] :: FieldDef -> !DBName
[fieldType] :: FieldDef -> !FieldType
[fieldSqlType] :: FieldDef -> !SqlType

-- | user annotations for a field
[fieldAttrs] :: FieldDef -> ![Attr]

-- | a strict field in the data type. Default: true
[fieldStrict] :: FieldDef -> !Bool
[fieldReference] :: FieldDef -> !ReferenceDef
data FieldType

-- | Optional module and name.
FTTypeCon :: Maybe Text -> Text -> FieldType
FTApp :: FieldType -> FieldType -> FieldType
FTList :: FieldType -> FieldType
data ForeignDef
ForeignDef :: !HaskellName -> !DBName -> !HaskellName -> !DBName -> ![(ForeignFieldDef, ForeignFieldDef)] -> ![Attr] -> Bool -> ForeignDef
[foreignRefTableHaskell] :: ForeignDef -> !HaskellName
[foreignRefTableDBName] :: ForeignDef -> !DBName
[foreignConstraintNameHaskell] :: ForeignDef -> !HaskellName
[foreignConstraintNameDBName] :: ForeignDef -> !DBName
[foreignFields] :: ForeignDef -> ![(ForeignFieldDef, ForeignFieldDef)]
[foreignAttrs] :: ForeignDef -> ![Attr]
[foreignNullable] :: ForeignDef -> Bool

-- | Used instead of FieldDef to generate a smaller amount of code
type ForeignFieldDef = (HaskellName, DBName)
newtype HaskellName
HaskellName :: Text -> HaskellName
[unHaskellName] :: HaskellName -> Text
data IsNullable
Nullable :: !WhyNullable -> IsNullable
NotNullable :: IsNullable
data OnlyUniqueException
OnlyUniqueException :: String -> OnlyUniqueException
data PersistException

-- | Generic Exception
PersistError :: Text -> PersistException
PersistMarshalError :: Text -> PersistException
PersistInvalidField :: Text -> PersistException
PersistForeignConstraintUnmet :: Text -> PersistException
PersistMongoDBError :: Text -> PersistException
PersistMongoDBUnsupported :: Text -> PersistException
data PersistFilter
Eq :: PersistFilter
Ne :: PersistFilter
Gt :: PersistFilter
Lt :: PersistFilter
Ge :: PersistFilter
Le :: PersistFilter
In :: PersistFilter
NotIn :: PersistFilter
data PersistUpdate
Assign :: PersistUpdate
Add :: PersistUpdate
Subtract :: PersistUpdate
Multiply :: PersistUpdate
Divide :: PersistUpdate
BackendSpecificUpdate :: Text -> PersistUpdate

-- | A raw value which can be stored in any backend and can be marshalled
--   to and from a <tt>PersistField</tt>.
data PersistValue
PersistText :: Text -> PersistValue
PersistByteString :: ByteString -> PersistValue
PersistInt64 :: Int64 -> PersistValue
PersistDouble :: Double -> PersistValue
PersistRational :: Rational -> PersistValue
PersistBool :: Bool -> PersistValue
PersistDay :: Day -> PersistValue
PersistTimeOfDay :: TimeOfDay -> PersistValue
PersistUTCTime :: UTCTime -> PersistValue
PersistNull :: PersistValue
PersistList :: [PersistValue] -> PersistValue
PersistMap :: [(Text, PersistValue)] -> PersistValue

-- | Intended especially for MongoDB backend
PersistObjectId :: ByteString -> PersistValue

-- | Using <a>PersistDbSpecific</a> allows you to use types specific to a
--   particular backend For example, below is a simple example of the
--   PostGIS geography type:
--   
--   <pre>
--   data Geo = Geo ByteString
--   
--   instance PersistField Geo where
--     toPersistValue (Geo t) = PersistDbSpecific t
--   
--     fromPersistValue (PersistDbSpecific t) = Right $ Geo $ Data.ByteString.concat ["'", t, "'"]
--     fromPersistValue _ = Left "Geo values must be converted from PersistDbSpecific"
--   
--   instance PersistFieldSql Geo where
--     sqlType _ = SqlOther "GEOGRAPHY(POINT,4326)"
--   
--   toPoint :: Double -&gt; Double -&gt; Geo
--   toPoint lat lon = Geo $ Data.ByteString.concat ["'POINT(", ps $ lon, " ", ps $ lat, ")'"]
--     where ps = Data.Text.pack . show
--   </pre>
--   
--   If Foo has a geography field, we can then perform insertions like the
--   following:
--   
--   <pre>
--   insert $ Foo (toPoint 44 44)
--   </pre>
PersistDbSpecific :: ByteString -> PersistValue

-- | There are 3 kinds of references 1) composite (to fields that exist in
--   the record) 2) single field 3) embedded
data ReferenceDef
NoReference :: ReferenceDef

-- | A ForeignRef has a late binding to the EntityDef it references via
--   HaskellName and has the Haskell type of the foreign key in the form of
--   FieldType
ForeignRef :: !HaskellName -> !FieldType -> ReferenceDef
EmbedRef :: EmbedEntityDef -> ReferenceDef
CompositeRef :: CompositeDef -> ReferenceDef

-- | A SelfReference stops an immediate cycle which causes non-termination
--   at compile-time (issue #311).
SelfReference :: ReferenceDef

-- | A SQL data type. Naming attempts to reflect the underlying Haskell
--   datatypes, eg SqlString instead of SqlVarchar. Different SQL databases
--   may have different translations for these types.
data SqlType
SqlString :: SqlType
SqlInt32 :: SqlType
SqlInt64 :: SqlType
SqlReal :: SqlType
SqlNumeric :: Word32 -> Word32 -> SqlType
SqlBool :: SqlType
SqlDay :: SqlType
SqlTime :: SqlType

-- | Always uses UTC timezone
SqlDayTime :: SqlType
SqlBlob :: SqlType

-- | a backend-specific name
SqlOther :: Text -> SqlType
data UniqueDef
UniqueDef :: !HaskellName -> !DBName -> ![(HaskellName, DBName)] -> ![Attr] -> UniqueDef
[uniqueHaskell] :: UniqueDef -> !HaskellName
[uniqueDBName] :: UniqueDef -> !DBName
[uniqueFields] :: UniqueDef -> ![(HaskellName, DBName)]
[uniqueAttrs] :: UniqueDef -> ![Attr]
data UpdateException
KeyNotFound :: String -> UpdateException
UpsertError :: String -> UpdateException

-- | The reason why a field is <tt>nullable</tt> is very important. A field
--   that is nullable because of a <tt>Maybe</tt> tag will have its type
--   changed from <tt>A</tt> to <tt>Maybe A</tt>. OTOH, a field that is
--   nullable because of a <tt>nullable</tt> tag will remain with the same
--   type.
data WhyNullable
ByMaybeAttr :: WhyNullable
ByNullableAttr :: WhyNullable


-- | This module contain MySQL-specific functions.
--   
--   <i>Since: 2.2.8</i>
module Database.Esqueleto.MySQL

-- | (<tt>random()</tt>) Split out into database specific modules because
--   MySQL uses `rand()`.
--   
--   <i>Since: 2.6.0</i>
random_ :: (PersistField a, Num a) => SqlExpr (Value a)


-- | This module contain PostgreSQL-specific functions.
--   
--   <i>Since: 2.2.8</i>
module Database.Esqueleto.PostgreSQL

-- | Aggregate mode
data AggMode

-- | ALL
AggModeAll :: AggMode

-- | DISTINCT
AggModeDistinct :: AggMode

-- | (<tt>array_agg</tt>) Concatenate distinct input values, including
--   <tt>NULL</tt>s, into an array.
--   
--   <i>Since: 2.5.3</i>
arrayAggDistinct :: (PersistField a, PersistField [a]) => SqlExpr (Value a) -> SqlExpr (Value (Maybe [a]))
arrayAgg :: PersistField a => SqlExpr (Value a) -> SqlExpr (Value (Maybe [a]))
arrayAggWith :: AggMode -> SqlExpr (Value a) -> [OrderByClause] -> SqlExpr (Value (Maybe [a]))

-- | (<tt>array_remove</tt>) Remove all elements equal to the given value
--   from the array.
--   
--   <i>Since: 2.5.3</i>
arrayRemove :: SqlExpr (Value [a]) -> SqlExpr (Value a) -> SqlExpr (Value [a])

-- | Remove <tt>NULL</tt> values from an array
arrayRemoveNull :: SqlExpr (Value [Maybe a]) -> SqlExpr (Value [a])

-- | (<tt>string_agg</tt>) Concatenate input values separated by a
--   delimiter.
--   
--   <i>Since: 2.2.8</i>
stringAgg :: SqlString s => SqlExpr (Value s) -> SqlExpr (Value s) -> SqlExpr (Value (Maybe s))

-- | (<tt>string_agg</tt>) Concatenate input values separated by a
--   delimiter.
stringAggWith :: SqlString s => AggMode -> SqlExpr (Value s) -> SqlExpr (Value s) -> [OrderByClause] -> SqlExpr (Value (Maybe s))

-- | Coalesce an array with an empty default value
maybeArray :: (PersistField a, PersistField [a]) => SqlExpr (Value (Maybe [a])) -> SqlExpr (Value [a])

-- | (<tt>chr</tt>) Translate the given integer to a character. (Note the
--   result will depend on the character set of your database.)
--   
--   <i>Since: 2.2.11</i>
chr :: SqlString s => SqlExpr (Value Int) -> SqlExpr (Value s)
now_ :: SqlExpr (Value UTCTime)

-- | (<tt>random()</tt>) Split out into database specific modules because
--   MySQL uses `rand()`.
--   
--   <i>Since: 2.6.0</i>
random_ :: (PersistField a, Num a) => SqlExpr (Value a)

-- | (Internal) Create a custom aggregate functions with aggregate mode
--   
--   <i>Do</i> <i>not</i> use this function directly, instead define a new
--   function and give it a type (see <a>unsafeSqlBinOp</a>)
unsafeSqlAggregateFunction :: UnsafeSqlFunctionArgument a => Builder -> AggMode -> a -> [OrderByClause] -> SqlExpr (Value b)
instance GHC.Show.Show Database.Esqueleto.PostgreSQL.AggMode


-- | This module contain SQLite-specific functions.
--   
--   <i>Since: 2.2.8</i>
module Database.Esqueleto.SQLite

-- | (<tt>random()</tt>) Split out into database specific modules because
--   MySQL uses `rand()`.
--   
--   <i>Since: 2.6.0</i>
random_ :: (PersistField a, Num a) => SqlExpr (Value a)
